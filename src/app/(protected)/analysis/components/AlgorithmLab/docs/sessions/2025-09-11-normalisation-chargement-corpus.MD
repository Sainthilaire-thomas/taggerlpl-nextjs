# üîß Plan de normalisation COMPLET du chargement de corpus AlgorithmLab (V2)

## üéØ Objectif

**SUPPRIMER** tous les hooks sp√©cialis√©s (useXAlgorithmTesting, useM1AlgorithmTesting, useM2AlgorithmTesting, useM3AlgorithmTesting) et **UNIFORMISER** sur le pattern Y ‚Üí BaseAlgorithmTesting ‚Üí useLevel1Testing.

## üìä Situation actuelle PROBL√âMATIQUE

### ‚ùå Hooks sp√©cialis√©s √† SUPPRIMER

| Hook                    | Probl√®mes identifi√©s                                     | Lignes de code |
| ----------------------- | -------------------------------------------------------- | -------------- |
| `useXAlgorithmTesting`  | 400+ lignes, logique complexe isol√©e, donn√©es mock       | ~430           |
| `useM1AlgorithmTesting` | Logique isol√©e, format sp√©cifique                        | ~50            |
| `useM2AlgorithmTesting` | **DONN√âES FACTICES** , pas les vraies donn√©es turntagged | ~120           |
| `useM3AlgorithmTesting` | Logique isol√©e, format sp√©cifique                        | ~80            |

### ‚úÖ R√©f√©rence CORRECTE √† suivre

**Y** utilise le pattern unifi√© :

```typescript
// YValidationInterface.tsx
<BaseAlgorithmTesting
  variableLabel="Y ‚Äî R√©actions Client"
  defaultClassifier="RegexYClassifier"
  target="Y"
/>
```

## üéØ DISTINCTION FONDAMENTALE : CIBLES vs MOYENS

### **CIBLES (ce qu'on veut mesurer)**

- **X** : Tagger le tour conseiller
- **Y** : Tagger le tour client
- **M1** : Densit√© verbes d'action dans le tour conseiller
- **M2** : Alignement entre tour conseiller ‚Üî tour client
- **M3** : Charge cognitive du tour client

### **MOYENS (donn√©es utilis√©es par les algorithmes)**

Selon l'algorithme, il peut utiliser :

- **Seulement le tour cible** (T0)
- **Tour + tour suivant** (T0 + T+1)
- **Contexte 2 tours pr√©c√©dents** (T-2, T-1, T0)
- **Contexte √©tendu** (T-2, T-1, T0, T+1)

## üìä **INVENTAIRE COMPLET DES ALGORITHMES**

### **üéØ Variable X (Strat√©gies Conseiller)**

| **Algorithme**        | **Contexte utilis√©** | **Format d'input**         | **Type**   |
| --------------------- | -------------------- | -------------------------- | ---------- |
| `RegexXClassifier`    | T0 seulement         | `string`                   | rule-based |
| `OpenAIXClassifier`   | T0 seulement         | `string`                   | llm        |
| `OpenAI3TXClassifier` | T-2, T-1, T0         | `string`(contexte 3 tours) | llm        |
| `SpacyXClassifier`    | T0 seulement         | `string`                   | ml         |

### **üéØ Variable Y (R√©actions Client)**

| **Algorithme**     | **Contexte utilis√©** | **Format d'input** | **Type**   |
| ------------------ | -------------------- | ------------------ | ---------- |
| `RegexYClassifier` | T0 seulement         | `string`           | rule-based |

### **üéØ Variable M1 (Densit√© verbes d'action)**

| **Algorithme**        | **Contexte utilis√©** | **Format d'input** | **Type**   |
| --------------------- | -------------------- | ------------------ | ---------- |
| `M1ActionVerbCounter` | T0 seulement         | `string`           | rule-based |

### **üéØ Variable M2 (Alignement T0 ‚Üî T+1)**

| **Algorithme**         | **Contexte utilis√©** | **Format d'input**       | **Type**   |
| ---------------------- | -------------------- | ------------------------ | ---------- |
| `M2LexicalAlignment`   | T0 + T+1             | `{t0, t1}`               | rule-based |
| `M2SemanticAlignment`  | T0 + T+1             | `{t0, t1}`               | rule-based |
| `M2CompositeAlignment` | T0 + T+1 + contexte  | `{t0, t1, prev1, prev2}` | hybrid     |

### **üéØ Variable M3 (Charge cognitive client)**

| **Algorithme**       | **Contexte utilis√©** | **Format d'input**  | **Type**   |
| -------------------- | -------------------- | ------------------- | ---------- |
| `PausesM3Calculator` | T0 seulement         | `M3Input {segment}` | rule-based |

## üîÑ SOLUTION : Migration vers pattern unifi√©

### √âtape 1: Configuration centralis√©e par algorithme

```typescript
// types/algorithms/base.ts - AJOUT √† votre fichier existant
export interface AlgorithmConfig {
  target: VariableTarget;
  speakerType: "conseiller" | "client";
  inputFormat:
    | "simple"
    | "contextual"
    | "alignment"
    | "alignment_context"
    | "cognitive";
  requiresNextTurn: boolean;
  requiresPrevContext: boolean;
}

// √Ä ajouter dans types/algorithms/base.ts
export const ALGORITHM_CONFIGS: Record<string, AlgorithmConfig> = {
  // === VARIABLE X ===
  RegexXClassifier: {
    target: "X",
    speakerType: "conseiller",
    inputFormat: "simple", // string simple
    requiresNextTurn: false,
    requiresPrevContext: false,
  },
  OpenAIXClassifier: {
    target: "X",
    speakerType: "conseiller",
    inputFormat: "simple", // string simple
    requiresNextTurn: false,
    requiresPrevContext: false,
  },
  OpenAI3TXClassifier: {
    target: "X",
    speakerType: "conseiller",
    inputFormat: "contextual", // Utilise 3 tours dans useLevel1Testing
    requiresNextTurn: false,
    requiresPrevContext: true, // ‚úÖ UTILISE prev1/prev2 existants
  },
  SpacyXClassifier: {
    target: "X",
    speakerType: "conseiller",
    inputFormat: "simple", // string simple
    requiresNextTurn: false,
    requiresPrevContext: false,
  },

  // === VARIABLE Y ===
  RegexYClassifier: {
    target: "Y",
    speakerType: "client",
    inputFormat: "simple", // string simple
    requiresNextTurn: false,
    requiresPrevContext: false,
  },

  // === VARIABLE M1 ===
  M1ActionVerbCounter: {
    target: "M1",
    speakerType: "conseiller",
    inputFormat: "simple", // string simple vers M1Input
    requiresNextTurn: false,
    requiresPrevContext: false,
  },

  // === VARIABLE M2 ===
  M2LexicalAlignment: {
    target: "M2",
    speakerType: "conseiller", // Part du conseiller
    inputFormat: "alignment", // {t0, t1} depuis useLevel1Testing
    requiresNextTurn: true, // ‚úÖ OBLIGATOIRE next_turn_verbatim
    requiresPrevContext: false,
  },
  M2SemanticAlignment: {
    target: "M2",
    speakerType: "conseiller",
    inputFormat: "alignment", // {t0, t1}
    requiresNextTurn: true, // ‚úÖ OBLIGATOIRE next_turn_verbatim
    requiresPrevContext: false,
  },
  M2CompositeAlignment: {
    target: "M2",
    speakerType: "conseiller",
    inputFormat: "alignment_context", // {t0, t1, prev1, prev2}
    requiresNextTurn: true, // ‚úÖ OBLIGATOIRE next_turn_verbatim
    requiresPrevContext: true, // ‚úÖ UTILISE prev1/prev2 existants
  },
};
```

### √âtape 2: Fonctions utilitaires centralis√©es (√Ä CR√âER)

```typescript
// utils/corpusFilters.ts - NOUVEAU FICHIER √Ä CR√âER
import { ALGORITHM_CONFIGS, AlgorithmConfig } from "../types/algorithms/base";

export const filterCorpusForAlgorithm = (
  goldStandardData: GoldStandardSample[], // ‚úÖ Type existant dans useLevel1Testing
  algorithmName: string
): GoldStandardSample[] => {
  const config = ALGORITHM_CONFIGS[algorithmName];
  if (!config) {
    console.warn(`No config found for algorithm: ${algorithmName}`);
    return goldStandardData;
  }

  let filtered = goldStandardData;

  // 1. Filtre par type de speaker (d√©j√† fait dans mapTurnsToGoldStandard)
  filtered = filtered.filter((sample) => {
    if (config.speakerType === "conseiller") {
      return sample.metadata?.target === "conseiller";
    } else {
      return sample.metadata?.target === "client";
    }
  });

  // 2. Filtre : n√©cessite next_turn_verbatim (M2 OBLIGATOIRE)
  if (config.requiresNextTurn) {
    filtered = filtered.filter(
      (s) =>
        s.metadata?.next_turn_verbatim &&
        s.metadata.next_turn_verbatim.trim().length > 0
    );
  }

  // 3. Filtre : n√©cessite contexte pr√©c√©dent (OpenAI3TXClassifier, M2Composite)
  if (config.requiresPrevContext) {
    filtered = filtered.filter(
      (s) => s.metadata?.prev1_turn_verbatim || s.metadata?.prev2_turn_verbatim
    );
  }

  return filtered;
};

// utils/inputPreparation.ts - NOUVEAU FICHIER √Ä CR√âER
import { ALGORITHM_CONFIGS } from "../types/algorithms/base";

export const prepareInputsForAlgorithm = (
  samples: GoldStandardSample[], // ‚úÖ Type existant
  algorithmName: string
): any[] => {
  const config = ALGORITHM_CONFIGS[algorithmName];
  if (!config) throw new Error(`Algorithm ${algorithmName} not configured`);

  return samples.map((sample) => {
    switch (config.inputFormat) {
      case "simple":
        // X (la plupart), Y, M1 : verbatim direct
        return sample.verbatim;

      case "contextual":
        // OpenAI3TXClassifier : format d√©j√† g√©r√© dans useLevel1Testing
        const m = sample.metadata || {};
        return `T-2: ${m.prev2_turn_verbatim ?? "‚Äî"}\nT-1: ${
          m.prev1_turn_verbatim ?? "‚Äî"
        }\nT0: ${sample.verbatim ?? ""}`;

      case "alignment":
        // M2 Lexical/Semantic : format basique
        return {
          t0: sample.verbatim,
          t1: sample.metadata?.next_turn_verbatim,
          conseillerTurn: sample.verbatim,
          clientTurn: sample.metadata?.next_turn_verbatim,
        };

      case "alignment_context":
        // M2 Composite : format √©tendu
        return {
          t0: sample.verbatim,
          t1: sample.metadata?.next_turn_verbatim,
          prev1: sample.metadata?.prev1_turn_verbatim,
          prev2: sample.metadata?.prev2_turn_verbatim,
          conseillerTurn: sample.verbatim,
          clientTurn: sample.metadata?.next_turn_verbatim,
        };

      case "cognitive":
        // M3 : format charge cognitive (PausesM3Calculator)
        return {
          segment: sample.verbatim,
          withProsody: false,
          language: "fr",
          options: {
            id: sample.metadata?.turnId,
            clientTurn: sample.verbatim,
            conseillerContext: sample.metadata?.prev1_turn_verbatim,
          },
        };

      default:
        return sample.verbatim;
    }
  });
};
```

### √âtape 3: Compl√©ter useLevel1Testing (MODIFICATION MINIMALE)

**useLevel1Testing est d√©j√† fonctionnel !** Il suffit de modifier `validateAlgorithm` pour utiliser les nouvelles fonctions :

```typescript
// Modification dans useLevel1Testing.ts
import { filterCorpusForAlgorithm } from "../utils/corpusFilters";
import { prepareInputsForAlgorithm } from "../utils/inputPreparation";

const validateAlgorithm = useCallback(
  async (
    classifierName: string,
    sampleSize?: number
  ): Promise<ValidationResult[]> => {
    // ‚úÖ AJOUT : Filtrage intelligent par algorithme
    const filteredBase = filterCorpusForAlgorithm(
      goldStandardData,
      classifierName
    );

    if (filteredBase.length === 0) {
      throw new Error(`Aucune donn√©e disponible pour ${classifierName}`);
    }

    const samples = randomSample(filteredBase, sampleSize);

    // ‚úÖ AJOUT : Pr√©paration d'inputs selon l'algorithme
    const inputs = prepareInputsForAlgorithm(samples, classifierName);

    // ‚úÖ GARDE : Le reste de la logique reste identique !
    const classifier = algorithmRegistry.get<any, any>(classifierName);
    // ... logique existante inchang√©e ...
  },
  [goldStandardData] // ‚úÖ goldStandardData reste la source unique
);
```

**Avantages** :

- ‚úÖ **Aucune rupture** : `goldStandardData` reste la source unique
- ‚úÖ **Logique existante pr√©serv√©e** : M1, M2, X, Y fonctionnent comme avant
- ‚úÖ **Filtrage intelligent** : Chaque algorithme re√ßoit exactement ses donn√©es
- ‚úÖ **Pr√©paration automatique** : Plus besoin de logique sp√©cialis√©e par hook

### √âtape 4: Migration des interfaces

#### AVANT (probl√©matique)

```typescript
// XValidationInterface.tsx - AVANT
import XAlgorithmTesting from "./XAlgorithmTesting";
export default function XValidationInterface() {
  return <XAlgorithmTesting />; // ‚ùå Hook isol√©
}

// M1ValidationInterface.tsx - AVANT
import M1AlgorithmTesting from "./M1AlgorithmTesting";
export default function M1ValidationInterface() {
  return <M1AlgorithmTesting />; // ‚ùå Hook isol√©
}
```

#### APR√àS (unifi√©)

```typescript
// XValidationInterface.tsx - APR√àS
import { BaseAlgorithmTesting } from "../BaseAlgorithmTesting";
export default function XValidationInterface() {
  return (
    <BaseAlgorithmTesting
      variableLabel="X ‚Äî Strat√©gies Conseiller"
      defaultClassifier="RegexXClassifier"
      target="X" // ‚Üê Auto-filtre les algorithmes X
      availableAlgorithms={[
        "RegexXClassifier",
        "OpenAIXClassifier",
        "OpenAI3TXClassifier",
        "SpacyXClassifier",
      ]}
    />
  );
}

// M1ValidationInterface.tsx - APR√àS
import { BaseAlgorithmTesting } from "../BaseAlgorithmTesting";
export default function M1ValidationInterface() {
  return (
    <BaseAlgorithmTesting
      variableLabel="M1 ‚Äî Densit√© de verbes d'action"
      defaultClassifier="M1ActionVerbCounter"
      target="M1"
      availableAlgorithms={["M1ActionVerbCounter"]}
    />
  );
}

// M2ValidationInterface.tsx - APR√àS (FIX CRITIQUE)
import { BaseAlgorithmTesting } from "../BaseAlgorithmTesting";
export default function M2ValidationInterface() {
  return (
    <BaseAlgorithmTesting
      variableLabel="M2 ‚Äî Alignement conseiller ‚Üî client"
      defaultClassifier="M2CompositeAlignment"
      target="M2"
      availableAlgorithms={[
        "M2CompositeAlignment",
        "M2LexicalAlignment",
        "M2SemanticAlignment",
      ]}
      // ‚ùå SUPPRIME les donn√©es factices
      // ‚úÖ UTILISE les vraies donn√©es via useLevel1Testing
    />
  );
}

// M3ValidationInterface.tsx - APR√àS
import { BaseAlgorithmTesting } from "../BaseAlgorithmTesting";
export default function M3ValidationInterface() {
  return (
    <BaseAlgorithmTesting
      variableLabel="M3 ‚Äî Charge cognitive client"
      defaultClassifier="PausesM3Calculator"
      target="M3"
      availableAlgorithms={["PausesM3Calculator"]}
    />
  );
}
```

## üóëÔ∏è FICHIERS √Ä SUPPRIMER

```bash
# Hooks sp√©cialis√©s √† SUPPRIMER compl√®tement
rm src/app/(protected)/analysis/components/AlgorithmLab/hooks/level1/useM1AlgorithmTesting.ts     # ~50 lignes
rm src/app/(protected)/analysis/components/AlgorithmLab/hooks/level1/useM2AlgorithmTesting.ts     # ~120 lignes (DONN√âES FACTICES)
rm src/app/(protected)/analysis/components/AlgorithmLab/hooks/level1/useM3AlgorithmTesting.ts     # ~80 lignes
rm src/app/(protected)/analysis/components/AlgorithmLab/hooks/level1/useXAlgorithmTesting.ts      # ~430 lignes

# Composants de test sp√©cialis√©s √† SUPPRIMER (si ils existent)
# rm src/components/Level1/algorithms/XClassifiers/XAlgorithmTesting.tsx
# rm src/components/Level1/algorithms/M1Calculators/M1AlgorithmTesting.tsx
# rm src/components/Level1/algorithms/M2Calculators/M2AlgorithmTesting.tsx
# rm src/components/Level1/algorithms/M3Calculators/M3AlgorithmTesting.tsx

# TOTAL : ~680 lignes de code supprim√©es + maintenance simplifi√©e
```

## üöÄ Plan d'impl√©mentation R√âVIS√â

### Phase 1: Cr√©ation des utilitaires (1-2h)

1. ‚úÖ Analyser l'existant (fait)
2. **Ajouter** `AlgorithmConfig` dans `types/algorithms/base.ts`
3. **Ajouter** `ALGORITHM_CONFIGS` dans `types/algorithms/base.ts`
4. Cr√©er `utils/corpusFilters.ts` avec `filterCorpusForAlgorithm`
5. Cr√©er `utils/inputPreparation.ts` avec `prepareInputsForAlgorithm`

### Phase 2: Modification minimale useLevel1Testing (1h)

1. Importer les nouvelles fonctions utilitaires
2. Modifier `validateAlgorithm` pour utiliser le filtrage/pr√©paration par algorithme
3. **AUCUNE rupture** : garder la logique existante M1/M2/X/Y
4. Tester avec un algorithme existant

### Phase 3: Migration progressive (2-3h)

1. **X** : Remplacer useXAlgorithmTesting par BaseAlgorithmTesting
2. **M1** : Remplacer useM1AlgorithmTesting par BaseAlgorithmTesting
3. **M2** : Remplacer useM2AlgorithmTesting par BaseAlgorithmTesting (PRIORIT√â - donn√©es factices)
4. **M3** : Remplacer useM3AlgorithmTesting par BaseAlgorithmTesting

### Phase 4: Nettoyage (30min)

1. Supprimer les 4 hooks sp√©cialis√©s
2. Tests de non-r√©gression
3. Documentation

## ‚úÖ R√©sultat final

**AVANT** : 5 syst√®mes diff√©rents, ~680 lignes de code dupliqu√©, donn√©es factices
**APR√àS** : 1 syst√®me unifi√©, donn√©es r√©elles partout, maintenance simplifi√©e

### Architecture cible unifi√©e

```
Level1Interface
‚îú‚îÄ‚îÄ XValidationInterface ‚Üí BaseAlgorithmTesting(target="X")
‚îú‚îÄ‚îÄ YValidationInterface ‚Üí BaseAlgorithmTesting(target="Y") ‚úÖ D√âJ√Ä OK
‚îú‚îÄ‚îÄ M1ValidationInterface ‚Üí BaseAlgorithmTesting(target="M1")
‚îú‚îÄ‚îÄ M2ValidationInterface ‚Üí BaseAlgorithmTesting(target="M2")
‚îî‚îÄ‚îÄ M3ValidationInterface ‚Üí BaseAlgorithmTesting(target="M3")

Tous utilisent:
‚îú‚îÄ‚îÄ useLevel1Testing (hook unifi√©)
‚îú‚îÄ‚îÄ mapTurnsToGoldStandard (donn√©es r√©elles)
‚îú‚îÄ‚îÄ algorithmRegistry (algorithmes centralis√©s)
‚îú‚îÄ‚îÄ ALGORITHM_CONFIGS (configuration par algorithme)
‚îú‚îÄ‚îÄ filterCorpusForAlgorithm (filtrage intelligent)
‚îî‚îÄ‚îÄ prepareInputsForAlgorithm (pr√©paration automatique)
```

### Avantages imm√©diats

1. **680+ lignes supprim√©es**
2. **Donn√©es r√©elles partout** (fin des mocks M2)
3. **1 seule logique** √† maintenir
4. **Configuration par algorithme** (flexibilit√© maximale)
5. **Comportement pr√©visible** et coh√©rent
6. **Tests simplifi√©s**
7. **Ajout d'algorithmes facilit√©**
8. **Distinction claire CIBLES vs MOYENS**

---

**üéØ PRIORIT√â 1 : Impl√©menter ALGORITHM_CONFIGS et les fonctions de filtrage/pr√©paration par algorithme**

**üéØ PRIORIT√â 2 : Corriger M2 pour utiliser les vraies donn√©es turntagged (plus de donn√©es factices)**
