# üìã Guide de migration AlgorithmLab - Harmonisation compl√®te

> **Objectif** : Supprimer le legacy et harmoniser tous les algorithmes sous `UniversalAlgorithm`
>
> **Principe** : Conserver 100% de la logique m√©tier, changer uniquement l'interface

## üéØ Vue d'ensemble de la migration

### √âtat actuel (h√©t√©rog√®ne)

```
RegexXClassifier implements XClassifier
M2LexicalAlignment extends BaseM2Calculator
M1ActionVerbCounter implements BaseAlgorithm
PausesM3Calculator extends BaseM3Calculator
```

### √âtat cible (unifi√©)

```
TOUS implements UniversalAlgorithm {
  describe(): AlgorithmDescriptor
  validateConfig(): boolean
  run(input: unknown): Promise<UniversalResult>
  batchRun?(inputs: unknown[]): Promise<UniversalResult[]>
}
```

## üìÅ Fichiers √† modifier (ordre de migration)

### Phase 1 : Interfaces et types (30 min)

#### 1.1 Cr√©er l'interface unifi√©e

```bash
# Cr√©er le fichier principal
touch algorithms/interfaces/UniversalAlgorithm.ts
```

**Contenu :**

```typescript
// algorithms/interfaces/UniversalAlgorithm.ts
export interface UniversalAlgorithm {
  describe(): AlgorithmDescriptor;
  validateConfig(): boolean;
  run(input: unknown): Promise<UniversalResult>;
  batchRun?(inputs: unknown[]): Promise<UniversalResult[]>;
}

export interface AlgorithmDescriptor {
  name: string;
  displayName: string;
  version: string;
  type: "rule-based" | "ml" | "llm" | "hybrid" | "metric";
  target: "X" | "Y" | "M1" | "M2" | "M3";
  batchSupported: boolean;
  requiresContext: boolean;
  description?: string;
  examples?: Array<{ input: unknown; output?: unknown; note?: string }>;
}

export interface UniversalResult {
  prediction: string;
  confidence: number;
  processingTime?: number;
  algorithmVersion?: string;
  metadata?: {
    inputType?: string;
    executionPath?: string[];
    warnings?: string[];
    details?: any;
  };
}
```

#### 1.2 Supprimer les fichiers legacy

```bash
# Supprimer les interfaces obsol√®tes
rm algorithms/level1/shared/legacyAdapters.ts
rm algorithms/level1/shared/BaseClassifier.ts
rm algorithms/level1/XAlgorithms/shared/BaseXClassifier.ts
rm algorithms/level1/YAlgorithms/shared/BaseYClassifier.ts
rm algorithms/level1/M1Algorithms/shared/BaseM1Calculator.ts
rm algorithms/level1/M2Algorithms/shared/BaseM2Calculator.ts
rm algorithms/level1/M3Algorithms/shared/BaseM3Calculator.ts
```

### Phase 2 : Registry simplifi√© (15 min)

#### 2.1 Refactorer AlgorithmRegistry.ts

```typescript
// algorithms/level1/shared/AlgorithmRegistry.ts
export class AlgorithmRegistry {
  private static algorithms = new Map<string, UniversalAlgorithm>();

  static register(name: string, algorithm: UniversalAlgorithm): void {
    // Validation stricte
    if (!algorithm.describe || !algorithm.run || !algorithm.validateConfig) {
      throw new Error(`${name} ne respecte pas UniversalAlgorithm`);
    }

    // Test m√©tadonn√©es
    const meta = algorithm.describe();
    if (!meta.name || !meta.target || !meta.type) {
      throw new Error(`${name} m√©tadonn√©es incompl√®tes`);
    }

    this.algorithms.set(name, algorithm);
    console.log(`‚úÖ ${name} enregistr√©`);
  }

  static get(name: string): UniversalAlgorithm | undefined {
    return this.algorithms.get(name);
  }

  static list(): Array<{ key: string; meta: AlgorithmDescriptor }> {
    return Array.from(this.algorithms.entries()).map(([key, algo]) => ({
      key,
      meta: algo.describe(),
    }));
  }

  static getByTarget(target: string) {
    return this.list().filter(({ meta }) => meta.target === target);
  }
}
```

### Phase 3 : Migration des algorithmes (2h)

#### 3.1 M1ActionVerbCounter (20 min) - Le plus simple

**Fichier :** `algorithms/level1/M1Algorithms/M1ActionVerbCounter.ts`

**Strat√©gie :** Wrapper minimal - garde tout le code existant

```typescript
// GARDE la classe existante, change juste l'interface
export class M1ActionVerbCounter implements UniversalAlgorithm {
  // NOUVEAU : Interface standardis√©e
  describe(): AlgorithmDescriptor {
    return {
      name: "M1ActionVerbCounter",
      displayName: "M1 - Densit√© verbes d'action",
      version: "1.0.0",
      type: "metric",
      target: "M1",
      batchSupported: true,
      requiresContext: false,
      description:
        "Calcul de la densit√© de verbes d'action dans le tour conseiller",
    };
  }

  validateConfig(): boolean {
    return true;
  }

  // NOUVEAU : Wrapper qui appelle l'ancien code
  async run(input: unknown): Promise<UniversalResult> {
    const verbatim = String(input);
    const startTime = Date.now();

    // APPEL de l'ancienne m√©thode toResult()
    const legacyResult = this.toResult(verbatim);

    return {
      prediction: legacyResult.prediction,
      confidence: legacyResult.confidence,
      processingTime: Date.now() - startTime,
      algorithmVersion: "1.0.0",
      metadata: {
        inputType: "string",
        executionPath: ["verb_analysis"],
        details: legacyResult.metadata,
      },
    };
  }

  // GARDE TOUT le code existant (private methods)
  private currentConfig = {
    /* config existante */
  };
  private baseActionLemmas = new Set([
    /* verbes existants */
  ]);
  private toResult(text: string) {
    /* m√©thode existante inchang√©e */
  }
  private countActionVerbs(text: string) {
    /* m√©thode existante */
  }
  // etc. TOUT le code priv√© reste identique
}
```

#### 3.2 RegexYClassifier (25 min)

**Fichier :** `algorithms/level1/YAlgorithms/RegexYClassifier.ts`

**Strat√©gie :** Renommer `run()` en `runLegacy()` et wrapper

```typescript
export class RegexYClassifier implements UniversalAlgorithm {
  // GARDE toute la config existante
  private config: YConfig;
  private dictionnaires = {
    /* dictionnaires existants */
  };

  describe(): AlgorithmDescriptor {
    return {
      name: "RegexYClassifier",
      displayName: "R√®gles - Y (client)",
      version: "1.0.0",
      type: "rule-based",
      target: "Y",
      batchSupported: true,
      requiresContext: false,
      description:
        "Classification des r√©actions client par dictionnaires pond√©r√©s",
    };
  }

  validateConfig(): boolean {
    return true;
  }

  // NOUVEAU wrapper
  async run(input: unknown): Promise<UniversalResult> {
    const verbatim = String(input);
    const startTime = Date.now();

    // APPEL ancien code
    const legacyResult = await this.runLegacy(verbatim);

    return {
      prediction: legacyResult.prediction,
      confidence: legacyResult.confidence,
      processingTime: legacyResult.processingTimeMs || Date.now() - startTime,
      algorithmVersion: "1.0.0",
      metadata: {
        inputType: "string",
        executionPath: ["dictionary_classification"],
        details: legacyResult.metadata,
      },
    };
  }

  // RENOMMER l'ancienne run() en runLegacy() - GARDE TOUT
  private async runLegacy(input: string): Promise<YClassification> {
    // COLLER ICI tout le code de l'ancienne run() sans modification
  }

  // GARDE TOUTES les m√©thodes priv√©es existantes
  private calculateScore() {
    /* inchang√© */
  }
  private pickPrediction() {
    /* inchang√© */
  }
  // etc.
}
```

#### 3.3 RegexXClassifier (25 min)

**Fichier :** `algorithms/level1/XAlgorithms/RegexXClassifier.ts`

**Strat√©gie :** Utiliser le code d√©j√† fourni dans l'artifact pr√©c√©dent

- GARDE toutes les regex patterns
- GARDE la logique hi√©rarchique
- GARDE les garde-fous REFLET_VOUS
- Wrapper `run()` ‚Üí `runLegacy()`

#### 3.4 M2LexicalAlignmentCalculator (25 min)

**Fichier :** `algorithms/level1/M2Algorithms/M2LexicalAlignmentCalculator.ts`

```typescript
export class M2LexicalAlignmentCalculator implements UniversalAlgorithm {
  // GARDE la config existante
  private config: LexicalConfig;

  describe(): AlgorithmDescriptor {
    return {
      name: "M2LexicalAlignment",
      displayName: "M2 - Alignement lexical",
      version: "1.0.0",
      type: "rule-based",
      target: "M2",
      batchSupported: true,
      requiresContext: true,
      description:
        "Score Jaccard entre T0 et T+1 (tokens FR, stopwords filtr√©s)",
    };
  }

  validateConfig(): boolean {
    return true;
  }

  async run(input: unknown): Promise<UniversalResult> {
    const m2Input = input as M2Input;
    const startTime = Date.now();

    // APPEL ancienne m√©thode calculate()
    const legacyResult = await this.calculate(m2Input);

    return {
      prediction: legacyResult.prediction,
      confidence: legacyResult.confidence,
      processingTime: legacyResult.processingTime || Date.now() - startTime,
      algorithmVersion: "1.0.0",
      metadata: {
        inputType: "M2Input",
        executionPath: ["tokenize", "jaccard", "classify"],
        details: legacyResult.details,
      },
    };
  }

  // GARDE la m√©thode calculate() existante
  async calculate(input: M2Input): Promise<CalculationResult<M2Details>> {
    // TOUT le code existant inchang√©
  }

  // GARDE toutes les m√©thodes priv√©es
  private getMetadata() {
    /* existant */
  }
  // etc.
}
```

#### 3.5 M2SemanticAlignmentCalculator (20 min)

**Fichier :** `algorithms/level1/M2Algorithms/M2SemanticAlignmentCalculator.ts`

M√™me strat√©gie que M2Lexical.

#### 3.6 M2CompositeAlignmentCalculator (20 min)

**Fichier :** `algorithms/level1/M2Algorithms/M2CompositeAlignmentCalculator.ts`

M√™me strat√©gie que M2Lexical.

#### 3.7 PausesM3Calculator (25 min)

**Fichier :** `algorithms/level1/M3Algorithms/PausesM3Calculator.tsx`

```typescript
export class PausesM3Calculator implements UniversalAlgorithm {
  describe(): AlgorithmDescriptor {
    return {
      name: "PausesM3Calculator",
      displayName: "M3 - Pauses et h√©sitations",
      version: "1.0.0",
      type: "metric",
      target: "M3",
      batchSupported: true,
      requiresContext: false,
      description: "Score de charge cognitive bas√© sur pauses/h√©sitations",
    };
  }

  validateConfig(): boolean {
    return true;
  }

  async run(input: unknown): Promise<UniversalResult> {
    const m3Input = this.normalizeInput(input);
    const startTime = Date.now();

    // APPEL ancienne m√©thode calculate()
    const legacyResult = await this.calculate(m3Input);

    return {
      prediction: legacyResult.prediction,
      confidence: legacyResult.confidence,
      processingTime: legacyResult.processingTime || Date.now() - startTime,
      algorithmVersion: "1.0.0",
      metadata: {
        inputType: "M3Input",
        executionPath: ["pause_detection", "hesitation_analysis"],
        details: legacyResult.details,
      },
    };
  }

  // GARDE toutes les m√©thodes existantes
  async calculate(input: M3Input) {
    /* code existant */
  }
  private normalizeInput() {
    /* code existant */
  }
  // etc.
}
```

### Phase 4 : Mise √† jour de initializeAlgorithms (15 min)

#### 4.1 Simplifier l'enregistrement

**Fichier :** `algorithms/level1/shared/initializeAlgorithms.ts`

```typescript
export function initializeAlgorithms(): void {
  console.log("üöÄ Initialisation AlgorithmLab harmonis√©");

  try {
    // === X (Conseiller) - Plus de wrapper ===
    algorithmRegistry.register("RegexXClassifier", new RegexXClassifier());

    // === Y (Client) ===
    algorithmRegistry.register("RegexYClassifier", new RegexYClassifier());

    // === M1 (Linguistique) ===
    algorithmRegistry.register(
      "M1ActionVerbCounter",
      new M1ActionVerbCounter()
    );

    // === M2 (Alignement) ===
    algorithmRegistry.register(
      "M2LexicalAlignment",
      new M2LexicalAlignmentCalculator()
    );
    algorithmRegistry.register(
      "M2SemanticAlignment",
      new M2SemanticAlignmentCalculator()
    );
    algorithmRegistry.register(
      "M2CompositeAlignment",
      new M2CompositeAlignmentCalculator()
    );

    // === M3 (Cognitif) ===
    algorithmRegistry.register("PausesM3Calculator", new PausesM3Calculator());

    const count = algorithmRegistry.list().length;
    console.log(`‚úÖ ${count} algorithmes harmonis√©s initialis√©s`);
  } catch (error) {
    console.error("‚ùå Erreur harmonisation:", error);
    throw error; // Fail fast
  }
}
```

#### 4.2 Supprimer les imports legacy

```bash
# Dans initializeAlgorithms.ts, supprimer :
# import { wrapXAlgorithm, wrapYAlgorithm, etc. }
```

### Phase 5 : Mise √† jour useLevel1Testing (10 min)

#### 5.1 Simplifier le hook

**Fichier :** `hooks/useLevel1Testing.ts`

```typescript
const validateAlgorithm = useCallback(
  async (
    algorithmName: string,
    sampleSize: number
  ): Promise<TVValidationResult[]> => {
    // Plus de fallback - registry strict
    const algorithm = algorithmRegistry.get(algorithmName);
    if (!algorithm) {
      throw new Error(`Algorithme ${algorithmName} introuvable`);
    }

    // Plus de try/catch sur describe() - obligatoire
    const meta = algorithm.describe();

    // Validation stricte
    if (!algorithm.validateConfig()) {
      throw new Error(`${algorithmName} mal configur√©`);
    }

    // Suite inchang√©e...
    const filteredSamples = filterCorpusForAlgorithm(
      goldStandardData,
      algorithmName
    );
    const samples = randomSample(filteredSamples, sampleSize);
    const inputs = prepareInputsForAlgorithm(samples, algorithmName);

    const results = await Promise.all(
      inputs.map(async (input, i) => {
        const sample = samples[i];
        const prediction = await algorithm.run(input); // Appel direct
        return mapToTVValidationResult(sample, prediction, meta);
      })
    );

    return results;
  },
  [goldStandardData]
);
```

### Phase 6 : Tests et validation (30 min)

#### 6.1 Script de validation

**Cr√©er :** `scripts/validateHarmonization.ts`

```typescript
// Script pour tester tous les algorithmes harmonis√©s
export async function validateAllAlgorithms() {
  console.log("üîç Validation harmonisation AlgorithmLab");

  const algorithms = algorithmRegistry.list();
  console.log(`üìä ${algorithms.length} algorithmes √† tester`);

  const testInputs = {
    X: "je vais v√©rifier votre dossier",
    Y: "d'accord merci beaucoup",
    M1: "je vais traiter votre demande imm√©diatement",
    M2: {
      t0: "je comprends votre situation",
      t1: "merci de votre compr√©hension",
    },
    M3: {
      segment: "euh... c'est... comment dire... compliqu√©",
      language: "fr",
    },
  };

  for (const { key, meta } of algorithms) {
    console.log(`\nüéØ Test ${key} (${meta.target}):`);

    const algo = algorithmRegistry.get(key);
    if (!algo) {
      console.error(`‚ùå ${key} introuvable`);
      continue;
    }

    try {
      // Test interface
      console.log(
        `   Interface: ${typeof algo.describe === "function" ? "‚úÖ" : "‚ùå"}`
      );
      console.log(`   Config: ${algo.validateConfig() ? "‚úÖ" : "‚ö†Ô∏è"}`);

      // Test ex√©cution
      const input = testInputs[meta.target];
      const start = Date.now();
      const result = await algo.run(input);
      const duration = Date.now() - start;

      console.log(`   Ex√©cution: ‚úÖ (${duration}ms)`);
      console.log(`   Pr√©diction: "${result.prediction}"`);
      console.log(`   Confiance: ${(result.confidence * 100).toFixed(1)}%`);
    } catch (error) {
      console.error(`‚ùå ${key}: ${error.message}`);
    }
  }
}
```

#### 6.2 Tests comparatifs

Tester que les r√©sultats avant/apr√®s migration sont identiques :

```typescript
// Pour chaque algo, comparer ancien vs nouveau r√©sultat
const oldResult = await oldAlgorithm.run(testInput);
const newResult = await newAlgorithm.run(testInput);

expect(newResult.prediction).toBe(oldResult.prediction);
expect(newResult.confidence).toBeCloseTo(oldResult.confidence, 2);
```

## üìã Checklist de migration

### Pr√©paration

- [ ] Backup du dossier `algorithms/level1`
- [ ] Cr√©er `algorithms/interfaces/UniversalAlgorithm.ts`
- [ ] Supprimer fichiers legacy (Base\*.ts, legacyAdapters.ts)

### Algorithmes (ordre recommand√©)

- [ ] M1ActionVerbCounter (simple)
- [ ] RegexYClassifier
- [ ] RegexXClassifier (complexe)
- [ ] M2LexicalAlignmentCalculator
- [ ] M2SemanticAlignmentCalculator
- [ ] M2CompositeAlignmentCalculator
- [ ] PausesM3Calculator

### Registry et hooks

- [ ] Refactorer AlgorithmRegistry.ts
- [ ] Nettoyer initializeAlgorithms.ts
- [ ] Simplifier useLevel1Testing.ts

### Validation

- [ ] Script validateHarmonization.ts
- [ ] Tests comparatifs ancien/nouveau
- [ ] Test de l'UI compl√®te

## üéØ Crit√®res de succ√®s

1. **Z√©ro r√©gression** : Tous les r√©sultats d'algorithmes identiques avant/apr√®s
2. **Interface homog√®ne** : Tous impl√©mentent `UniversalAlgorithm`
3. **Registry strict** : Plus de fallback, validation √† l'enregistrement
4. **Code simple** : 50% moins de fichiers, logique plus claire
5. **Performance** : Plus de couches d'abstraction legacy

## üí° Notes importantes

- **Conserver 100% de la logique m√©tier** - Ne jamais toucher aux patterns/algorithmes
- **Wrapper minimal** - Juste changer l'interface, pas la logique
- **Migration incremental** - Tester apr√®s chaque algorithme
- **Fail fast** - Registry strict pour d√©tecter les erreurs t√¥t
- **Compatibilit√©** - L'UI existing doit continuer √† fonctionner

Cette migration vous donnera une architecture AlgorithmLab propre et homog√®ne, pr√™te pour ajouter de nouveaux algorithmes facilement.

## 7 Normaliser les sorties

Tu as raison ‚Äî **on arr√™te les rustines** . On se met d‚Äôaccord sur **une sortie unique (`UniversalResult`)** et **un seul adaptateur** qui transforme _n‚Äôimporte quel_ r√©sultat en **`TVValidationResult`** consommable par l‚ÄôUI, **sans que l‚ÄôUI connaisse les d√©tails de chaque algo** .

Voici le plan propre et _universel_ qui marche pour **X/Y** (classifieurs) **et M1/M2/M3** (m√©triques), en s‚Äôalignant sur ton M1 d√©j√† clean.

---

# Architecture cible (simple & stable)

1. **Chaque algorithme retourne un `UniversalResult`** avec au minimum :

   - `prediction: string`
   - `confidence: number`
   - `processingTime?: number`
   - `algorithmVersion?: string`
   - `metadata: { target: "X" | "Y" | "M1" | "M2" | "M3", details?: object }`

   ### Convention par type de target

   - **X/Y (classifieurs)**

     `metadata.details = { family: string, evidences?: string[] }`

   - **M1/M2/M3 (m√©triques)**

     `metadata = { metric: "M1" | "M2" | "M3", value?/density?, ‚Ä¶ }`

     (Ton M1 convient d√©j√†, on n‚Äôexige pas `details` ici.)

2. **Un seul adaptateur `normalizeUniversalToTV`** (niveau hook) transforme un `UniversalResult` en **`TVValidationResult`** que l‚ÄôUI conna√Æt d√©j√† (famille/√©vidences pour X/Y, bloc m1/m2/m3 pour m√©triques).
3. **L‚ÄôUI (`ResultsPanel`, `ExtraColumns`, `MetricsPanel`) ne lit que `TVValidationResult`** et n‚Äôinspecte plus jamais `algorithmMetadata`. Ainsi, **ajouter un nouvel algo = 0 changement UI** .

---

# A. Adaptateur universel (√† ajouter)

Cr√©e (ou colle) ce fichier utilitaire, p. ex. `hooks/normalizeUniversalToTV.ts` :

<pre class="overflow-visible!" data-start="1563" data-end="4055"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-ts"><span><span>import</span><span></span><span>type</span><span> { </span><span>UniversalResult</span><span> } </span><span>from</span><span></span><span>"@/app/(protected)/analysis/components/AlgorithmLab/types/algorithms/base"</span><span>;

</span><span>export</span><span></span><span>type</span><span></span><span>TVValidationResult</span><span> = {
  </span><span>verbatim</span><span>: </span><span>string</span><span>;
  </span><span>goldStandard</span><span>: </span><span>string</span><span>;
  </span><span>predicted</span><span>: </span><span>string</span><span>;
  </span><span>confidence</span><span>: </span><span>number</span><span>;
  </span><span>correct</span><span>: </span><span>boolean</span><span>;
  processingTime?: </span><span>number</span><span>;
  metadata?: </span><span>Record</span><span><</span><span>string</span><span>, </span><span>any</span><span>>;
};

</span><span>type</span><span></span><span>AdaptConfig</span><span> = {
  </span><span>target</span><span>: </span><span>"X"</span><span> | </span><span>"Y"</span><span> | </span><span>"M1"</span><span> | </span><span>"M2"</span><span> | </span><span>"M3"</span><span>;
};

</span><span>export</span><span></span><span>function</span><span></span><span>normalizeUniversalToTV</span><span>(
  uni: UniversalResult,
  sample: { verbatim: </span><span>string</span><span>; expectedTag: </span><span>string</span><span> },
  cfg: AdaptConfig
): </span><span>TVValidationResult</span><span> {
  </span><span>const</span><span></span><span>meta</span><span>: </span><span>any</span><span> = uni.</span><span>metadata</span><span> ?? {};
  </span><span>const</span><span> target = (meta.</span><span>target</span><span></span><span>as</span><span></span><span>AdaptConfig</span><span>[</span><span>"target"</span><span>]) || cfg.</span><span>target</span><span>;

  </span><span>// valeurs communes</span><span>
  </span><span>const</span><span> predicted = </span><span>String</span><span>(uni.</span><span>prediction</span><span> ?? </span><span>""</span><span>);
  </span><span>const</span><span> confidence = </span><span>Number</span><span>(uni.</span><span>confidence</span><span> ?? </span><span>0</span><span>);
  </span><span>const</span><span> correct = predicted === sample.</span><span>expectedTag</span><span>;

  </span><span>// mapping sp√©cifique par famille d‚Äôalgo</span><span>
  </span><span>let</span><span></span><span>specific</span><span>: </span><span>Record</span><span><</span><span>string</span><span>, </span><span>any</span><span>> = {};

  </span><span>if</span><span> (target === </span><span>"X"</span><span> || target === </span><span>"Y"</span><span>) {
    </span><span>const</span><span> details = meta.</span><span>details</span><span> ?? {};
    </span><span>const</span><span> family = details.</span><span>family</span><span> ?? meta.</span><span>family</span><span> ?? </span><span>null</span><span>;
    </span><span>const</span><span></span><span>evidences</span><span>: </span><span>string</span><span>[] =
      details.</span><span>evidences</span><span> ?? meta.</span><span>evidences</span><span> ?? meta.</span><span>rationales</span><span> ?? [];

    </span><span>if</span><span> (target === </span><span>"X"</span><span>) {
      specific = {
        </span><span>x_details</span><span>: family ? { family } : </span><span>undefined</span><span>,
        </span><span>x_evidences</span><span>: evidences.</span><span>length</span><span> ? evidences : </span><span>undefined</span><span>,
      };
    } </span><span>else</span><span> {
      specific = {
        </span><span>y_details</span><span>: family ? { family } : </span><span>undefined</span><span>,
        </span><span>y_evidences</span><span>: evidences.</span><span>length</span><span> ? evidences : </span><span>undefined</span><span>,
      };
    }
  }

  </span><span>if</span><span> (target === </span><span>"M1"</span><span>) {
    </span><span>// Ton M1 d√©j√† migr√© expose ces champs dans metadata</span><span>
    specific = {
      </span><span>m1</span><span>: {
        </span><span>value</span><span>: meta.</span><span>value</span><span> ?? meta.</span><span>density</span><span> ?? </span><span>undefined</span><span>,
        </span><span>densityPer</span><span>: meta.</span><span>densityPer</span><span>,
        </span><span>actionVerbCount</span><span>: meta.</span><span>actionVerbCount</span><span>,
        </span><span>totalTokens</span><span>: meta.</span><span>totalTokens</span><span>,
        </span><span>verbsFound</span><span>: meta.</span><span>verbsFound</span><span>,
      },
    };
  }

  </span><span>if</span><span> (target === </span><span>"M2"</span><span>) {
    specific = {
      </span><span>m2</span><span>: {
        </span><span>value</span><span>: meta.</span><span>value</span><span>,
        </span><span>scale</span><span>: meta.</span><span>scale</span><span>,
      },
    };
  }

  </span><span>if</span><span> (target === </span><span>"M3"</span><span>) {
    specific = {
      </span><span>m3</span><span>: {
        </span><span>value</span><span>: meta.</span><span>value</span><span>,
        </span><span>unit</span><span>: meta.</span><span>unit</span><span> ?? </span><span>"ms"</span><span>,
      },
    };
  }

  </span><span>return</span><span> {
    </span><span>verbatim</span><span>: sample.</span><span>verbatim</span><span>,
    </span><span>goldStandard</span><span>: sample.</span><span>expectedTag</span><span>,
    predicted,
    confidence,
    correct,
    </span><span>processingTime</span><span>: uni.</span><span>processingTime</span><span>,
    </span><span>metadata</span><span>: {
      </span><span>// utile pour tracer</span><span>
      target,
      </span><span>algorithmVersion</span><span>: uni.</span><span>algorithmVersion</span><span>,
      </span><span>executionPath</span><span>: meta.</span><span>executionPath</span><span>,
      </span><span>// ce que l‚ÄôUI consomme :</span><span>
      ...specific,
    },
  };
}
</span></span></code></div></div></pre>

> Remarques :
>
> - On **ne lit plus `algorithmMetadata`** c√¥t√© UI. Tout passe par `TVValidationResult.metadata`.
> - Pour **X/Y** , on ne d√©pend que de `details.family` et `details.evidences` (avec fallback sur racine si besoin).
> - Pour **M1** , on r√©cup√®re directement ce que M1 expose (ton code est d√©j√† good).

---

# B. `useLevel1Testing.ts` ‚Äî utilise l‚Äôadaptateur (et basta)

Dans `validateAlgorithm`, **remplace le bloc qui construisait ‚Äú√† la main‚Äù** `ValidationResult` par un appel √† l‚Äôadaptateur :

<pre class="overflow-visible!" data-start="4563" data-end="5134"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-ts"><span><span>import</span><span> { normalizeUniversalToTV } </span><span>from</span><span></span><span>"./normalizeUniversalToTV"</span><span>; </span><span>// adapte le chemin</span><span>

</span><span>// ...</span><span>
</span><span>const</span><span> results = </span><span>await</span><span></span><span>Promise</span><span>.</span><span>all</span><span>(
  inputs.</span><span>map</span><span>(</span><span>async</span><span> (input, i) => {
    </span><span>const</span><span> sample = samples[i];
    </span><span>const</span><span> uni = </span><span>await</span><span> classifier.</span><span>run</span><span>(input); </span><span>// ‚Üê chaque algo retourne UniversalResult</span><span>

    </span><span>// inf√©rer le target depuis la config de l‚Äôalgo (d√©j√† dans ton hook)</span><span>
    </span><span>const</span><span> config = </span><span>getConfigForAlgorithm</span><span>(classifierName);
    </span><span>const</span><span> target = (config?.</span><span>target</span><span></span><span>as</span><span></span><span>"X"</span><span> | </span><span>"Y"</span><span> | </span><span>"M1"</span><span> | </span><span>"M2"</span><span> | </span><span>"M3"</span><span>) ?? </span><span>"X"</span><span>;

    </span><span>return</span><span></span><span>normalizeUniversalToTV</span><span>(uni, sample, { target });
  })
);
</span></span></code></div></div></pre>

üëâ Du coup, **plus aucun switch/case dans le hook** .

üëâ La logique de mapping est **dans une seule fonction** , testable et stable.

üëâ **L‚ÄôUI n‚Äôa pas besoin de changer** √† chaque nouvel algo.

---

# C. Algorithmes ‚Äî exigences minimales

- **Toujours renvoyer `metadata.target`** (utile au tra√ßage).

  - M1 : ajoute `metadata.target: "M1"` (optionnel si on inf√®re c√¥t√© hook via config, mais c‚Äôest plus propre).
  - X/Y : ajoute `metadata.target: "X"` / `"Y"`.

- **X/Y** : remplir **uniquement**

  `metadata.details = { family, evidences? }`

  (Pas besoin de dupliquer ailleurs si tu appliques l‚Äôadaptateur ci-dessus.)

- **M1** : **tu es d√©j√† align√©** (tes champs sont sous `metadata.*`). Rien √† changer, sauf `metadata.target: "M1"` si tu veux.

---

# D. UI (`ExtraColumns`, `MetricsPanel`, `ResultsTableBase`)

- L‚ÄôUI lit **exclusivement `TVValidationResult`** :

  - **Famille X** : `r.metadata?.x_details?.family`
  - **√âvidences X** : `r.metadata?.x_evidences`
  - **M1** : `r.metadata?.m1.{value, actionVerbCount, ‚Ä¶}`

- **Supprime** les lectures de `algorithmMetadata` ou de chemins alternatifs.

  ‚Üí L‚ÄôUI est **aveugle au format interne** des algos.

---

## Pourquoi ton M1 ‚Äún‚Äôa pas le probl√®me‚Äù ?

Parce qu‚Äôil **remplit d√©j√†** un `UniversalResult` propre et que, dans tes vues actuelles, on lit ses champs m√©tiers (`density`, `actionVerbCount`, ‚Ä¶) **toujours aux m√™mes cl√©s** .

En reproduisant la m√™me discipline pour X/Y (via `details.family/evidences` + adaptateur unique), on obtient **la m√™me robustesse** .

---

# comment √ßa marche (sch√©ma simple)

1. **Corpus ‚Üí Gold**

   `mapTurnsToGoldStandard(...)` transforme tes tours en **GoldStandardSample[]**

   ‚Üí chaque item a :

   - `verbatim`
   - `expectedTag` (le label gold, normalis√©)
   - `metadata` **(contexte que tu veux voir dans l‚ÄôUI)** : `prev1_turn_verbatim`, `next_turn_verbatim`, `annotations`, etc.

2. **Validation** (dans `useLevel1Testing.validateAlgorithm`)

   Pour chaque sample s√©lectionn√© :

   - on pr√©pare l‚Äôinput selon l‚Äôalgo (`prepareInputsForAlgorithm`) ‚Äî **indispensable pour M1** ;
   - on appelle l‚Äôalgo et on r√©cup√®re un **UniversalResult** ;
   - on passe ce r√©sultat au **normaliseur** `normalizeUniversalToTV(...)` ‚Üí il te fabrique des champs standard pour l‚ÄôUI :
     - si `target = "X"` ‚Üí `metadata.x_details.family`, `metadata.x_evidences[]`
     - si `target = "Y"` ‚Üí `metadata.y_*`
     - si `target = "M1"` ‚Üí `metadata.m1.*` (densit√©, etc.)
   - **on fusionne** le **contexte du sample** + la **m√©ta normalis√©e** pour constituer `row.metadata`.

   √Ä la fin, `validateAlgorithm` renvoie un tableau de **ValidationResult[]** (c‚Äôest ce que la table attend).

3. **UI**

   - `ResultsPanel` appelle `validateAlgorithm` et r√©cup√®re `ValidationResult[]`.
   - `ResultsTableBase` / `extraColumns.tsx` lisent **uniquement** `row.metadata` :
     - colonne ‚ÄúFamille X‚Äù ‚Üí `row.metadata?.x_details?.family`
     - colonne ‚Äú√âvidences‚Äù ‚Üí `row.metadata?.x_evidences`

üëâ si `x_details`/`x_evidences` ne sont pas pr√©sents dans `row.metadata`, tu verras ‚Äú‚Äî‚Äù.

---

# les 3 types √† conna√Ætre

- **UniversalResult** (retourn√© par tes algos) ‚Äì forme minimale :
  <pre class="overflow-visible!" data-start="1876" data-end="2212"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-ts"><span><span>{
    </span><span>prediction</span><span>: </span><span>string</span><span>;
    </span><span>confidence</span><span>: </span><span>number</span><span>;
    </span><span>processingTime</span><span>: </span><span>number</span><span>;
    algorithmVersion?: </span><span>string</span><span>;
    metadata?: {
      target?: </span><span>"X"</span><span>|</span><span>"Y"</span><span>|</span><span>"M1"</span><span>|</span><span>"M2"</span><span>|</span><span>"M3"</span><span>;
      details?: {
        family?: </span><span>string</span><span>;
        evidences?: </span><span>string</span><span>[]; </span><span>// ou evs/matches ‚Äî le normaliseur tol√®re</span><span>
      };
      [</span><span>k</span><span>: </span><span>string</span><span>]: </span><span>any</span><span>;
    }
  }
  </span></span></code></div></div></pre>
- **ValidationResult** (ce que la table attend) :
  <pre class="overflow-visible!" data-start="2266" data-end="2512"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-ts"><span><span>{
    </span><span>verbatim</span><span>: </span><span>string</span><span>;
    </span><span>goldStandard</span><span>: </span><span>string</span><span>;
    </span><span>predicted</span><span>: </span><span>string</span><span>;
    </span><span>confidence</span><span>: </span><span>number</span><span>;
    </span><span>correct</span><span>: </span><span>boolean</span><span>;
    processingTime?: </span><span>number</span><span>;
    metadata?: </span><span>Record</span><span><</span><span>string</span><span>, </span><span>any</span><span>>; </span><span>// ‚Üê ici on met contexte + champs normalis√©s</span><span>
  }
  </span></span></code></div></div></pre>
- **GoldStandardSample** (ton gold) :
  <pre class="overflow-visible!" data-start="2554" data-end="2677"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-ts"><span><span>{
    </span><span>verbatim</span><span>: </span><span>string</span><span>;
    </span><span>expectedTag</span><span>: </span><span>string</span><span>;
    metadata?: { ...contexte prev/next/annotations... };
  }
  </span></span></code></div></div></pre>

> On n‚Äôintroduit **aucun** autre type (pas de `TVValidationResult`, etc.). √áa √©vite les erreurs TS que tu viens d‚Äôavoir.
