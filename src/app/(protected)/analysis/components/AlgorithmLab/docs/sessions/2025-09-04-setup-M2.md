# Documentation Session M2 - Branchement Variable M2 (Alignement Interactionnel)

## D√©veloppements r√©cents (Session M2)

### 1. Algorithmes M2 d'alignement textuel

- **Nouveau M2LexicalAlignmentCalculator** avec overlap lexical T0‚ÜîT+1
- **M2SemanticAlignmentCalculator** d√©tection patterns d'alignement
- **M2CompositeAlignmentCalculator** fusion pond√©r√©e lexical+s√©mantique
- **M√©triques sp√©cialis√©es** : Jaccard, intersection, reformulations
- **Support batch processing** optimis√© pour gros volumes

### 2. Int√©gration pipeline M2 complet

- **Enregistrement dans initializeAlgorithms.ts** avec configuration
- **Hook useM2AlgorithmTesting** pour validation technique
- **API endpoints** `/api/algolab/m2/test` et `/api/algolab/m2/batch`
- **M2ValidationInterface** fonctionnel avec RunPanel et s√©lecteur
- **Int√©gration Level1Interface** avec onglet M2 op√©rationnel

### 3. M√©triques et visualisation M2

- **MetricsPanel classification** pour cat√©gories alignement
- **Colonnes extraColumns M2** : valeur, score lexical, tokens partag√©s
- **ResultsPanel int√©gr√©** avec targetKind="M2" complet
- **Cache intelligent** pour calculs d'alignement r√©p√©t√©s
- **Export fine-tuning** des erreurs d'alignement annot√©es

---

## Points d'attention technique

1. **Donn√©es disponibles** : Focus sur textuel (turntagged), prosodique ult√©rieur
2. **Types M2Details** : Coh√©rence value/scale/details pour UI
3. **Performance batch** : Optimisation calculs lexicaux r√©p√©t√©s
4. **Gold standard M2** : Annotation manuelle alignement si n√©cessaire
5. **Seuils calibrage** : Thresholds lexical/s√©mantique √† ajuster

### Bonnes pratiques impl√©ment√©es

1. **Architecture modulaire** M2 avec BaseM2Calculator abstrait
2. **Validation configuration** automatique pour chaque algorithme
3. **Gestion d'erreurs granulaire** avec fallback gracieux
4. **Cache multi-niveaux** pour tokens et scores d'alignement
5. **Interface responsive** adapt√©e aux diff√©rents types de r√©sultats
6. **S√©paration concerns** : calcul vs pr√©sentation vs m√©triques
7. **Support th√®me adaptatif** pour tous les composants M2
8. **Tests automatis√©s** avec √©chantillons gold standard
9. **Documentation JSDoc** compl√®te des algorithmes
10. **Monitoring performance** temps de calcul et pr√©cision

## Structure de donn√©es critiques M2

```typescript
// Interface M2Input (donn√©es d'entr√©e)
interface M2Input {
  turnVerbatim: string; // T0 - tour conseiller analys√©
  nextTurnVerbatim: string; // T+1 - r√©action client suivante
  context?: {
    prevTurn?: string; // T-1 optionnel pour contexte
    speaker?: string; // locuteur T0 (conseiller/client)
    nextSpeaker?: string; // locuteur T+1 (client/conseiller)
  };
  metadata?: {
    turnId?: number;
    callId?: string;
    timestamp?: number;
  };
}

// Interface M2Details (r√©sultat sp√©cialis√©)
interface M2Details {
  alignmentType: "align√©" | "partiellement_align√©" | "non_align√©";
  lexicalScore: number; // 0-1 (Jaccard, intersection)
  semanticScore?: number; // 0-1 (patterns d√©tect√©s)
  sharedTokens?: string[]; // tokens communs identifi√©s
  patterns?: string[]; // patterns linguistiques trouv√©s
  justification: string; // explication du calcul
  confidence: number; // 0-1 confiance dans la classification
  processingTime?: number; // ms pour debug performance
}

// Structure TVMetadata.m2 (pour ResultsPanel)
interface TVMetadata {
  m2?: {
    value?: string; // cat√©gorie d'alignement
    scale?: string; // "nominal" | "ordinal"
    details?: M2Details; // d√©tails techniques complets
  };
}
```

## Composants cl√©s d√©velopp√©s

### 1. üßÆ M2LexicalAlignmentCalculator - Alignement lexical

**Localisation** : `algorithms/level1/M2Algorithms/M2LexicalAlignmentCalculator.ts`

**Fonctionnalit√©s** :

- **Calcul Jaccard** entre ensembles de tokens T0 et T+1
- **Intersection pond√©r√©e** avec importance par fr√©quence
- **Normalisation** : casse, accents, lemmatisation optionnelle
- **Filtrage stop-words** configurablement

**M√©triques produites** :

```typescript
{
  lexicalScore: 0.75,           // Score Jaccard
  sharedTokens: ["v√©rifier", "dossier"],
  intersectionSize: 2,
  unionSize: 8,
  alignmentType: "align√©"       // si score > seuil
}
```

### 2. üîç M2SemanticAlignmentCalculator - Patterns linguistiques

**Localisation** : `algorithms/level1/M2Algorithms/M2SemanticAlignmentCalculator.ts`

**Patterns d√©tect√©s** :

- **Acquiescement** : "d'accord", "oui", "parfait", "tr√®s bien"
- **Reformulation** : reprise avec variation lexicale
- **Question de clarification** : "combien", "quand", "comment"
- **Objection** : "mais", "cependant", "je ne suis pas d'accord"
- **Action-response** : verbe d'action conseiller ‚Üí r√©action client

**Configuration** :

```typescript
{
  patterns: ["acquiescement", "reformulation", "action_response"],
  strictMode: false,           // tol√©rance variations
  contextWeight: 0.3,          // poids contexte T-1
  confidenceThreshold: 0.6
}
```

### 3. ‚öñÔ∏è M2CompositeAlignmentCalculator - Fusion algorithmes

**Localisation** : `algorithms/level1/M2Algorithms/M2CompositeAlignmentCalculator.ts`

**Strat√©gie de fusion** :

```typescript
{
  lexicalWeight: 0.4,          // poids score lexical
  semanticWeight: 0.6,         // poids score s√©mantique
  threshold: 0.5,              // seuil "align√©" vs "non_align√©"
  partialThreshold: 0.3,       // seuil "partiellement_align√©"
  normalization: "minmax"      // normalisation scores
}
```

**Calcul score final** :

```typescript
finalScore = lexicalScore * lexicalWeight + semanticScore * semanticWeight;
classification =
  finalScore > threshold
    ? "align√©"
    : finalScore > partialThreshold
    ? "partiellement_align√©"
    : "non_align√©";
```

### 4. üîó useM2AlgorithmTesting - Hook de validation

**Localisation** : `hooks/level1/useM2AlgorithmTesting.ts`

**Fonctionnalit√©s cl√©s** :

- **Fetch gold standard** depuis turntagged avec next_turn_verbatim
- **Ex√©cution batch** des algorithmes M2 s√©lectionn√©s
- **Formatage TVValidationResult** avec metadata M2 compl√®te
- **Gestion √©tats** : running, results, errors, progress
- **Configuration dynamique** : sample size, algorithme actif

**Interface** :

```typescript
const {
  isRunning,
  results, // TVValidationResult[] avec M2
  runTest, // (sampleSize: number) => Promise<void>
  selectedAlgorithm, // string (nom calculateur)
  setSelectedAlgorithm, // (name: string) => void
  availableAlgorithms, // AlgorithmInfo[]
  progress, // { current: number, total: number }
  goldStandardCount, // nombre total paires disponibles
} = useM2AlgorithmTesting();
```

### 5. üìä M2ValidationInterface - Interface de test compl√®te

**Localisation** : `algorithms/M2Calculators/M2ValidationInterface.tsx`

**Architecture** :

```typescript
export default function M2ValidationInterface() {
  const m2Hook = useM2AlgorithmTesting();
  const [sampleSize, setSampleSize] = useState(50);

  return (
    <Stack gap={2}>
      {/* Panel de configuration */}
      <RunPanel
        isRunning={m2Hook.isRunning}
        isConfigValid={true}
        goldStandardCount={m2Hook.goldStandardCount}
        sampleSize={sampleSize}
        onSampleSizeChange={setSampleSize}
        onRun={() => m2Hook.runTest(sampleSize)}
        domainLabel="Alignement M2"
        supportsBatch={true}
      />

      {/* S√©lecteur algorithme */}
      <AlgorithmSelector
        algorithms={m2Hook.availableAlgorithms}
        selectedAlgorithm={m2Hook.selectedAlgorithm}
        onAlgorithmChange={m2Hook.setSelectedAlgorithm}
        target="M2"
      />

      {/* R√©sultats avec m√©triques M2 */}
      {m2Hook.results.length > 0 && (
        <ResultsPanel
          results={m2Hook.results}
          targetKind="M2" // ‚Üê CRUCIAL pour colonnes M2
          classifierLabel={m2Hook.selectedAlgorithm}
          initialPageSize={25}
        />
      )}
    </Stack>
  );
}
```

## Flux de donn√©es et optimisations M2

### 1. Pipeline de calcul M2

```
1. Fetch √©chantillon turntagged avec next_turn_verbatim non-null
2. Construction M2Input pour chaque paire (T0, T+1)
3. Ex√©cution algorithme M2 s√©lectionn√© (lexical/semantic/composite)
4. Calcul M2Details avec scores et classification
5. Formatage TVValidationResult avec metadata.m2 compl√®te
6. Affichage ResultsPanel avec colonnes M2 + m√©triques
7. Cache r√©sultats pour r√©utilisation (tokens communs, patterns)
```

### 2. Optimisations performance

- **Cache tokens** : √âviter re-tokenisation verbatims identiques
- **Batch processing** : Traitement parall√®le √©chantillons
- **Lazy loading** : Chargement patterns s√©mantiques √† la demande
- **Memoization** : Cache scores lexicaux pour paires r√©p√©t√©es
- **Index patterns** : Pr√©-compilation regex pour patterns fr√©quents

### 3. Gestion des erreurs

```typescript
try {
  const result = await m2Calculator.calculate(input);
  return formatM2Result(result);
} catch (error) {
  if (error instanceof ValidationError) {
    return createErrorResult("VALIDATION", error.message);
  } else if (error instanceof TimeoutError) {
    return createErrorResult("TIMEOUT", "Calcul M2 timeout");
  } else {
    return createErrorResult("UNKNOWN", "Erreur interne M2");
  }
}
```

---

## Notes importantes pour la prochaine session

### üìã √âtat actuel M2

**Fonctionnalit√©s op√©rationnelles** :

- ‚úÖ Algorithmes M2 textuels (lexical, s√©mantique, composite)
- ‚úÖ Pipeline de test complet avec useM2AlgorithmTesting
- ‚úÖ Interface M2ValidationInterface fonctionnelle
- ‚úÖ Int√©gration ResultsPanel avec targetKind="M2"
- ‚úÖ M√©triques classification sp√©cialis√©es M2
- ‚úÖ Colonnes extraColumns M2 compl√®tes

**Composants cl√©s M2** :

- ‚úÖ `M2LexicalAlignmentCalculator` avec m√©triques Jaccard
- ‚úÖ `M2SemanticAlignmentCalculator` avec patterns linguistiques
- ‚úÖ `M2CompositeAlignmentCalculator` avec fusion pond√©r√©e
- ‚úÖ `useM2AlgorithmTesting` hook validation compl√®te
- ‚úÖ Enregistrement `initializeAlgorithms.ts` M2 section

### üîß Points d'attention M2

1. **Validation empirique** : Tester sur √©chantillon r√©el turntagged
2. **Calibrage seuils** : Ajuster thresholds lexical/s√©mantique/composite
3. **Gold standard** : Consid√©rer annotation manuelle si n√©cessaire
4. **Performance batch** : Optimiser pour >1000 paires simultan√©es
5. **Patterns √©tendus** : Enrichir d√©tection patterns s√©mantiques

### üìä M√©triques M2 attendues

```typescript
// Classification M2 (utilise MetricsPanelClassification)
interface M2Metrics {
  accuracy: number; // % classifications correctes
  precisionByCategory: {
    // Pr√©cision par type alignement
    align√©: number;
    partiellement_align√©: number;
    non_align√©: number;
  };
  recallByCategory: {
    // Rappel par type
    align√©: number;
    partiellement_align√©: number;
    non_align√©: number;
  };
  f1ScoreByCategory: {
    // F1 par type
    align√©: number;
    partiellement_align√©: number;
    non_align√©: number;
  };
  kappa: number; // Accord inter-annotateur si gold
  avgProcessingTime: number; // ms moyen par calcul
  avgConfidence: number; // Confiance moyenne 0-1
}
```

### üéØ Prochaines √©tapes M2

1. **Tests validation** : Lancer M2ValidationInterface sur √©chantillon
2. **Analyse erreurs** : Identifier patterns de mauvaise classification
3. **Fine-tuning seuils** : Optimiser thresholds selon m√©triques
4. **Documentation** : Compl√©ter JSDoc algorithmes M2
5. **Benchmarks** : Comparer performance lexical vs s√©mantique vs composite
6. **Pr√©paration prosodique** : Architecture pour M2 temporel/prosodique futur

Cette session M2 √©tablit les **fondations de l'alignement interactionnel textuel** , pr√©parant l'extension vers les **donn√©es prosodiques et temporelles** pour une analyse M2 multimodale compl√®te conforme aux hypoth√®ses de la th√®se.

### üî¨ Validation hypoth√®ses M2

**H2 - Alignement interactionnel** : Les strat√©gies efficaces (ENGAGEMENT, OUVERTURE) devraient g√©n√©rer des scores M2 √©lev√©s, tandis que les strat√©gies probl√©matiques (EXPLICATION) devraient montrer des d√©salignements.

**Pr√©dictions testables** :

- ENGAGEMENT ‚Üí M2 "align√©" (score lexical + patterns action-response)
- OUVERTURE ‚Üí M2 "align√©" (score s√©mantique + acquiescements)
- EXPLICATION ‚Üí M2 "non_align√©" (faible score + patterns objection)
- REFLET ‚Üí M2 variable selon sous-type (VOUS > JE > ACQ)

## ‚úÖ Ce qui a √©t√© fait pendant la session

### 1) Algorithmes M2 (textuels)

- **M2LexicalAlignmentCalculator** : score Jaccard T0‚ÜîT+1, tokens partag√©s, seuils `thresholdAligned/thresholdPartial`.
- **M2SemanticAlignmentCalculator** : d√©tection de **patterns** (acquiescement, reformulation, clarification, objection, action-response), score s√©mantique ‚àà [0,1].
- **M2CompositeAlignmentCalculator** : **fusion pond√©r√©e** (poids par d√©faut 0.4/0.6) des scores lexical & s√©mantique, seuils `threshold/partialThreshold`.

### 2) Utilitaires

- `m2-utils.ts` : `normalize()`, `tokenize()`, `jaccard()`, `shared()` avec stop-words FR.

### 3) Base & int√©gration

- **BaseM2Calculator** : interface commune (`calculate`, `getMetadata`, `validateConfig`) + **`describe()`** pour compat UI/registry.
- **initializeAlgorithms.ts** : ajout d‚Äôun **wrapper `wrapM2`** afin d‚Äôexposer `describe`/`classify`/`run` comme les autres algos (X/Y/M1), et **enregistrement** des 3 M2.
- **OpenAI X** : correction du constructeur (retrait de la propri√©t√© non typ√©e `apiKey`).

### 4) UI & hook

- **Compatibilit√© `ResultsPanel`** gr√¢ce √† `targetKind="M2"` (colonnes sp√©cifiques : cat√©gorie, `lexicalScore`, `sharedTokens`, `patterns`, etc.).
- **Hook `useM2AlgorithmTesting`** : s√©lection d‚Äôalgo M2, ex√©cution batch sur paires `{turnVerbatim, nextTurnVerbatim}`, formatage `TVValidationResult` (avec `metadata.m2.details`).

---

## üìÇ Arborescence & fichiers concern√©s

<pre class="overflow-visible!" data-start="1726" data-end="2056"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre!"><span><span>algorithms/level1/
  ‚îú‚îÄ shared/
  ‚îÇ   ‚îî‚îÄ BaseM2Calculator.ts          (unique !)
  ‚îî‚îÄ M2Algorithms/
      ‚îú‚îÄ m2-utils.ts
      ‚îú‚îÄ M2LexicalAlignmentCalculator.ts
      ‚îú‚îÄ M2SemanticAlignmentCalculator.ts
      ‚îî‚îÄ M2CompositeAlignmentCalculator.ts

algorithms/level1/shared/initializeAlgorithms.ts   (imports + register M2)
</span></span></code></div></div></pre>

> ‚ö†Ô∏è **Attention au nom de fichier** : `M2LexicalAlignmentCalculator.ts` (et non `M2LexicalAlignementCalculator.ts`).

---

## ‚ö†Ô∏è Probl√®mes bloquants restants (avec plan de fix)

### P1) Typo d‚Äôimport (emp√™che l‚Äôinit M2)

- **Erreur** : `Cannot find module '../M2Algorithms/M2LexicalAlignementCalculator'`
- **Cause** : fichier import√© avec `Alignement` (fr) au lieu de `Alignment`.
- **Fix** : renommer l‚Äôimport **et** s‚Äôassurer que le fichier s‚Äôappelle `M2LexicalAlignmentCalculator.ts`.

**Snippet √† appliquer**

<pre class="overflow-visible!" data-start="2572" data-end="2697"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-ts"><span><span>// initializeAlgorithms.ts</span><span>
</span><span>import</span><span> M2LexicalAlignmentCalculator </span><span>from</span><span></span><span>"../M2Algorithms/M2LexicalAlignmentCalculator"</span><span>;
</span></span></code></div></div></pre>

---

### P2) BaseM2Calculator dupliqu√©e

- **Erreur potentielle** : deux d√©finitions cons√©cutives du m√™me fichier ‚Üí incoh√©rences au build.
- **Fix** : ne garder **qu‚Äôun seul** `BaseM2Calculator.ts` (celui avec `describe()`), supprimer le doublon.

**Doit rester**

<pre class="overflow-visible!" data-start="2962" data-end="3263"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-ts"><span><span>export</span><span></span><span>abstract</span><span></span><span>class</span><span></span><span>BaseM2Calculator</span><span> {
  </span><span>abstract</span><span></span><span>calculate</span><span>(...): </span><span>Promise</span><span><</span><span>CalculationResult</span><span><M2Details>>;
  </span><span>abstract</span><span></span><span>getMetadata</span><span>(): </span><span>CalculationMetadata</span><span>;
  </span><span>abstract</span><span></span><span>validateConfig</span><span>(): </span><span>boolean</span><span>;

  </span><span>describe</span><span>(</span><span></span><span>) { </span><span>/* construit √† partir de getMetadata() */</span><span> }

  </span><span>async</span><span> batchCalculate? (...) { ... }
}
</span></span></code></div></div></pre>

---

### P3) Type import√© inexistant dans `M2CompositeAlignmentCalculator`

- **Erreur** : `Module './shared/BaseM2Calculator' has no exported member 'ClassificationResultM2'`.
- **Cause** : tentative d‚Äôimport d‚Äôun type qui n‚Äôexiste pas.
- **Fix** : utiliser les types d√©j√† expos√©s par **`types/Level1Types`** (`CalculationResult`, `M2Details`, `M2Input`, `CalculationMetadata`).

  ‚Üí Le fichier a √©t√© **r√©√©crit complet** pour impl√©menter `getMetadata()` et retourner `CalculationResult<M2Details>`.

**Fichier corrig√© (d√©j√† fourni dans la session)**

`M2CompositeAlignmentCalculator.ts` ‚Äî version avec `getMetadata()` + fusion pond√©r√©e.

---

### P4) `describe()` manquant c√¥t√© registry / objets enregistr√©s

- **Sympt√¥me** : `TypeError: algo.describe is not a function` lors du listing.
- **Cause** : certaines entr√©es du registry n‚Äôexposent pas `describe()`, ou bien M2 √©tait enregistr√© **sans** l‚Äôadaptateur.
- **Fix** : toujours enregistrer M2 **via `wrapM2(...)`** (et pas l‚Äôimpl directe), puisque `wrapM2` **garantit** `describe()`, `classify()` et `run()`.

**Exemple d‚Äôenregistrement**

<pre class="overflow-visible!" data-start="4359" data-end="4529"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-ts"><span><span>const</span><span> impl = </span><span>new</span><span></span><span>M2LexicalAlignmentCalculator</span><span>({ </span><span>thresholdAligned</span><span>: </span><span>0.5</span><span>, </span><span>thresholdPartial</span><span>: </span><span>0.3</span><span> });
algorithmRegistry.</span><span>register</span><span>(</span><span>"M2LexicalAlignment"</span><span>, </span><span>wrapM2</span><span>(impl));
</span></span></code></div></div></pre>

---

### P5) Incompatibilit√©s de type √† l‚Äôenregistrement (TS2345)

- **Sympt√¥me** : ‚ÄúArgument of type ‚Ä¶ not assignable to parameter of type ‚ÄòBaseAlgorithm‚Äô‚Ä¶‚Äù
- **Causes** :
  1. `wrapM2` imposait une signature trop stricte √† `getMetadata()`.
  2. `describe().type` attend un **enum interne** du registry, pas un `string` libre.
- **Fix** :
  - Assouplir la signature : `getMetadata(): any` et reconstituer `id/displayName/version` avec **fallbacks s√ªrs** .
  - Caster `type` et `target` : `type: "algorithm" as any`, `target: "M2" as any`.

**Signature de `wrapM2` (version tol√©rante)**

<pre class="overflow-visible!" data-start="5118" data-end="5316"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-ts"><span><span>function</span><span></span><span>wrapM2</span><span>(calc: {
  getMetadata: () => </span><span>any</span><span>;
  validateConfig: () => </span><span>boolean</span><span>;
  calculate: (input: </span><span>any</span><span>) => </span><span>Promise</span><span><GenericResult>;
}) { </span><span>/* construit describe(), classify(), run() */</span><span> }
</span></span></code></div></div></pre>

---

### P6) Propri√©t√© `apiKey` non typ√©e dans les configs OpenAI (TS2353)

- **Erreur** : `'apiKey' does not exist in type ...`
- **Cause** : tes classes `OpenAIXClassifier`/`OpenAI3TXClassifier` ne prennent pas `apiKey` dans l‚Äôobjet de config TS.
- **Fix** : **retirer** `apiKey` des objets pass√©s au constructeur (les classes lisent la cl√© via `process.env`).

**Snippet**

<pre class="overflow-visible!" data-start="5693" data-end="5830"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-ts"><span><span>new</span><span></span><span>OpenAIXClassifier</span><span>({
  </span><span>model</span><span>: </span><span>"gpt-4o-mini"</span><span>,
  </span><span>temperature</span><span>: </span><span>0</span><span>,
  </span><span>maxTokens</span><span>: </span><span>6</span><span>,
  </span><span>timeout</span><span>: </span><span>10000</span><span>,
  </span><span>enableFallback</span><span>: </span><span>true</span><span>,
});
</span></span></code></div></div></pre>

---

## ‚úÖ √âtat stabilis√© attendu apr√®s correctifs

- `algorithmRegistry.list()` fonctionne (plus d‚Äôerreur `describe()`).
- Les 3 algos M2 sont bien **visibles** (target = M2) et **ex√©cutables** via :
  - √©crans g√©n√©riques ‚Üí `classify(string)` renvoie un **placeholder propre** (`M2_REQUIRES_PAIR`),
  - √©crans M2 d√©di√©s ‚Üí `run({ turnVerbatim, nextTurnVerbatim })` (ou hook M2) effectue le calcul r√©el.
- `ResultsPanel` affiche les **colonnes M2** si `targetKind="M2"`.

---

## üîé Plan de v√©rification rapide (apr√®s patch)

1. **Build TS**

   <pre class="overflow-visible!" data-start="6375" data-end="6406"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre!"><span><span>pnpm</span><span> tsc --</span><span>no</span><span>Emit
   </span></span></code></div></div></pre>

   ‚Üí doit √™tre propre.

2. **D√©marrer l‚Äôapp** et ouvrir l‚Äôonglet **M2** :

   - le s√©lecteur affiche **M2LexicalAlignment** , **M2SemanticAlignment** , **M2CompositeAlignment** ,
   - un run de test affiche des r√©sultats avec `lexicalScore`/`patterns`/`confidence`.

3. **API interne (optionnel)**

   - `getAlgorithmStatus()` : v√©rifier `target: "M2"` sur 3 entr√©es.

---

## üìå To-do ‚Äúprochaine session‚Äù

1. **Finaliser les patchs ci-dessus**
   - ‚úîÔ∏è Import `M2LexicalAlignmentCalculator` (nom correct)
   - ‚úîÔ∏è Supprimer fichier doublonn√© `BaseM2Calculator`
   - ‚úîÔ∏è Utiliser la version corrig√©e de `M2CompositeAlignmentCalculator.ts`
   - ‚úîÔ∏è Enregistrer M2 **via `wrapM2(impl)`**
   - ‚úîÔ∏è Retirer `apiKey` des configs OpenAI
2. **Sanity checks**
   - V√©rifier que **tous** les M2 ont `getMetadata()` complet (id, displayName, version‚Ä¶).
   - Confirmer que `wrapM2` est la **m√™me** version tol√©rante que ci-dessus.
3. **Optionnel (apr√®s stabilisation)**
   - Consolider les **types** (`M2Input`, `M2Details`, `CalculationResult`, `CalculationMetadata`) ‚Üí **un module canonique** , avec shims pour compat (on le fera plus tard, comme d√©cid√©).
   - Benchmarks : comparer **latence** & **confiance** lexical vs s√©mantique vs composite sur un √©chantillon r√©el.
   - Ajuster les **seuils** selon distribution (ROC simple).

---

## Annexes ‚Äì Signatures & snippets de r√©f√©rence

### `wrapM2` (version finale conseill√©e)

<pre class="overflow-visible!" data-start="7826" data-end="9470"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-ts"><span><span>type</span><span></span><span>GenericResult</span><span> = {
  </span><span>prediction</span><span>: </span><span>string</span><span>;
  </span><span>confidence</span><span>: </span><span>number</span><span>;
  processingTime?: </span><span>number</span><span>;
  metadata?: </span><span>Record</span><span><</span><span>string</span><span>, </span><span>unknown</span><span>>;
};

</span><span>function</span><span></span><span>wrapM2</span><span>(calc: {
  getMetadata: () => </span><span>any</span><span>;
  validateConfig: () => </span><span>boolean</span><span>;
  calculate: (input: </span><span>any</span><span>) => </span><span>Promise</span><span><GenericResult>;
}) {
  </span><span>return</span><span> {
    </span><span>describe</span><span>(</span><span></span><span>) {
      </span><span>const</span><span> md = (</span><span>typeof</span><span> calc.</span><span>getMetadata</span><span> === </span><span>"function"</span><span> ? calc.</span><span>getMetadata</span><span>() : {}) ?? {};
      </span><span>const</span><span> displayName = md.</span><span>displayName</span><span> ?? md.</span><span>name</span><span> ?? md.</span><span>id</span><span> ?? </span><span>"M2 Calculator"</span><span>;
      </span><span>const</span><span> id = md.</span><span>id</span><span> ?? md.</span><span>name</span><span> ?? displayName.</span><span>replace</span><span>(</span><span>/\s+/g</span><span>, </span><span>""</span><span>);
      </span><span>const</span><span> version = md.</span><span>version</span><span> ?? </span><span>"1.0.0"</span><span>;
      </span><span>const</span><span> batchSupported = !!(md.</span><span>supportsBatch</span><span> ?? md.</span><span>batchSupported</span><span>);
      </span><span>const</span><span> description = md.</span><span>description</span><span> ?? </span><span>undefined</span><span>;
      </span><span>return</span><span> {
        </span><span>name</span><span>: id,
        displayName,
        </span><span>type</span><span>: </span><span>"algorithm"</span><span></span><span>as</span><span></span><span>any</span><span>,
        </span><span>target</span><span>: </span><span>"M2"</span><span></span><span>as</span><span></span><span>any</span><span>,
        version,
        batchSupported,
        description,
      };
    },
    </span><span>validateConfig</span><span>: </span><span>() =></span><span> calc.</span><span>validateConfig</span><span>(),
    </span><span>async</span><span></span><span>classify</span><span>(</span><span>verbatim</span><span>: </span><span>string</span><span>): </span><span>Promise</span><span><</span><span>GenericResult</span><span>> {
      </span><span>return</span><span> {
        </span><span>prediction</span><span>: </span><span>"M2_REQUIRES_PAIR"</span><span>,
        </span><span>confidence</span><span>: </span><span>0</span><span>,
        </span><span>metadata</span><span>: { </span><span>warning</span><span>: </span><span>"M2 attend {turnVerbatim,nextTurnVerbatim}."</span><span>, </span><span>sample</span><span>: verbatim },
      };
    },
    </span><span>async</span><span></span><span>run</span><span>(</span><span>input</span><span>: </span><span>any</span><span>): </span><span>Promise</span><span><</span><span>GenericResult</span><span>> {
      </span><span>if</span><span> (input && </span><span>typeof</span><span> input === </span><span>"object"</span><span> && </span><span>"turnVerbatim"</span><span></span><span>in</span><span> input && </span><span>"nextTurnVerbatim"</span><span></span><span>in</span><span> input) {
        </span><span>return</span><span> calc.</span><span>calculate</span><span>(input);
      }
      </span><span>return</span><span> {
        </span><span>prediction</span><span>: </span><span>"M2_INPUT_INVALID"</span><span>,
        </span><span>confidence</span><span>: </span><span>0</span><span>,
        </span><span>metadata</span><span>: { </span><span>error</span><span>: </span><span>"M2 attend {turnVerbatim,nextTurnVerbatim}."</span><span>, </span><span>receivedKeys</span><span>: </span><span>Object</span><span>.</span><span>keys</span><span>(input ?? {}) },
      };
    },
  };
}
</span></span></code></div></div></pre>

### Enregistrements M2 (identiques √† X/Y/M1)

<pre class="overflow-visible!" data-start="9517" data-end="9994"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-ts"><span><span>algorithmRegistry.</span><span>register</span><span>(</span><span>"M2LexicalAlignment"</span><span>,   </span><span>wrapM2</span><span>(</span><span>new</span><span></span><span>M2LexicalAlignmentCalculator</span><span>({ </span><span>thresholdAligned</span><span>: </span><span>0.5</span><span>, </span><span>thresholdPartial</span><span>: </span><span>0.3</span><span> })));
algorithmRegistry.</span><span>register</span><span>(</span><span>"M2SemanticAlignment"</span><span>,  </span><span>wrapM2</span><span>(</span><span>new</span><span></span><span>M2SemanticAlignmentCalculator</span><span>({ </span><span>confidenceThreshold</span><span>: </span><span>0.6</span><span>, </span><span>strictMode</span><span>: </span><span>false</span><span> })));
algorithmRegistry.</span><span>register</span><span>(</span><span>"M2CompositeAlignment"</span><span>, </span><span>wrapM2</span><span>(</span><span>new</span><span></span><span>M2CompositeAlignmentCalculator</span><span>({ </span><span>lexicalWeight</span><span>: </span><span>0.4</span><span>, </span><span>semanticWeight</span><span>: </span><span>0.6</span><span>, </span><span>threshold</span><span>: </span><span>0.5</span><span>, </span><span>partialThreshold</span><span>: </span><span>0.3</span><span> })));
</span></span></code></div></div></pre>

---

Si tu veux, je peux aussi te pr√©parer une **checklist CLI** (suite de commandes et grep) pour valider automatiquement les imports/exports & l‚Äôenregistrement dans le registry.
