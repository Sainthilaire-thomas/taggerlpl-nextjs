# ğŸ“Š Flux de donnÃ©es AlgorithmLab - Test d'algorithmes

> **Pattern unifiÃ© basÃ© sur M1** (rÃ©fÃ©rence correcte)
>
> X/Y suivront ce mÃªme modÃ¨le aprÃ¨s migration complÃ¨te

## ğŸ”„ Vue d'ensemble

```mermaid
flowchart TD
    A[Level1Interface] --> B[M2ValidationInterface]
    B --> C[BaseAlgorithmTesting]
    C --> D[useLevel1Testing Hook unifiÃ©]
    D --> E[TaggingDataContext]
    D --> F[algorithmRegistry]
    D --> G[ResultsPanel]

    E --> H[mapTurnsToGoldStandard]
    F --> I[Algorithm.run]
    H --> J[TVValidationResult]
    I --> J
    J --> G
```

## ğŸ“‹ Ã‰tape par Ã©tape dÃ©taillÃ©e

### 1ï¸âƒ£ **Interface utilisateur (Level1Interface)**

```typescript
// L'utilisateur sÃ©lectionne l'onglet M2
<Tabs value={variable} onChange={(_, v) => setVariable(v)}>
  <Tab label="M2 (Alignement Xâ†’Y)" value="M2" />
</Tabs>;

// Ceci monte le composant correspondant
{
  variable === "M2" && <M2ValidationInterface />;
}
```

### 2ï¸âƒ£ **ValidationInterface (Pattern unifiÃ©)**

```typescript
// M2ValidationInterface utilise BaseAlgorithmTesting
return (
  <BaseAlgorithmTesting
    target="M2" // â† DÃ©termine le filtre des donnÃ©es
    defaultAlgorithm="M2CompositeAlignment"
    onRun={(sampleSize) => {
      // Appelle useLevel1Testing.validateAlgorithm()
    }}
  />
);
```

### 3ï¸âƒ£ **Hook unifiÃ© (useLevel1Testing)**

#### **A. Chargement des donnÃ©es rÃ©elles**

```typescript
const { allTurnTagged } = useTaggingData();

// Construction du gold standard unifiÃ©
const goldStandardData = useMemo(
  () => mapTurnsToGoldStandard(allTurnTagged, allowedConseiller),
  [allTurnTagged, allowedConseiller]
);
```

#### **B. Mapping unifiÃ© des donnÃ©es**

```typescript
// mapTurnsToGoldStandard crÃ©e des Ã©chantillons avec contexte complet
{
  verbatim: t.verbatim,                    // T0 (tour principal)
  expectedTag: normalizeLabel(t.tag),      // Gold standard
  metadata: {
    target: "conseiller",                  // Filtre par variable
    callId: t.call_id,
    turnId: t.id,

    // ğŸ¯ CONTEXTE COMPLET (clÃ© pour M2)
    prev2_turn_verbatim: p2?.verbatim,
    prev1_turn_verbatim: p1?.verbatim,
    current_turn_verbatim: t.verbatim,     // T0
    next_turn_verbatim: t.next_turn_verbatim, // T+1

    // MÃ©tadonnÃ©es pour bouton Annotations
    annotations: Array.isArray(t.annotations) ? t.annotations : [],

    // IDs pour navigation
    prev2_turn_id: p2?.id,
    prev1_turn_id: p1?.id,
    next_turn_id: nextTurn?.id,
  }
}
```

#### **C. Filtrage par target (automatique)**

```typescript
const validateAlgorithm = useCallback(async (classifierName, sampleSize) => {
  const classifier = algorithmRegistry.get(classifierName);
  const target = getClassificationTarget(classifierName); // "M2"

  // âœ… Filtre automatique selon l'algorithme sÃ©lectionnÃ©
  const base = goldStandardData.filter(s => s.metadata?.target === target);

  // Pour M2: filtre les Ã©chantillons conseiller avec next_turn_verbatim
  const m2Base = base.filter(s => s.metadata?.next_turn_verbatim);

  const samples = randomSample(m2Base, sampleSize);
```

#### **D. PrÃ©paration des inputs (spÃ©cifique M2)**

```typescript
// Pour M2, on construit l'objet { t0, t1, ... }
const inputs = samples.map((sample) => ({
  t0: sample.verbatim, // Tour conseiller
  t1: sample.metadata.next_turn_verbatim, // Tour client suivant
  prev1: sample.metadata.prev1_turn_verbatim, // Contexte T-1
  prev2: sample.metadata.prev2_turn_verbatim, // Contexte T-2

  // MÃ©tadonnÃ©es pour l'algorithme
  conseillerTurn: sample.verbatim,
  clientTurn: sample.metadata.next_turn_verbatim,
}));
```

#### **E. ExÃ©cution de l'algorithme**

```typescript
// Route unifiÃ©e pour tous les algorithmes
const results = await Promise.all(
  inputs.map(async (input, i) => {
    const sample = samples[i];

    // Appel unifiÃ©
    const prediction = await classifier.run(input);

    // Mapping vers format tableau unifiÃ©
    return {
      // âœ… CHAMPS OBLIGATOIRES pour ResultsTableBody
      verbatim: sample.verbatim, // Colonne principale
      predicted: prediction.prediction, // Sortie algorithme
      goldStandard: sample.expectedTag, // Tag manuel (ENGAGEMENT, etc.)
      confidence: prediction.confidence,
      processingTime: prediction.processingTime,
      correct: undefined, // M2 = pas de score correct/incorrect

      // âœ… MÃ‰TADONNÃ‰ES OBLIGATOIRES pour contexte
      metadata: {
        ...sample.metadata, // HÃ©rite du contexte complet

        // Infos algorithme pour header
        classifier: classifierName,
        type: "hybrid",

        // RÃ©sultats M2 spÃ©cifiques
        m2: {
          value: prediction.prediction, // ALIGNEMENT_FORT/FAIBLE/DESALIGNEMENT
          scale: "composite",
          lexicalScore: prediction.details?.lexicalAlignment,
          semanticScore: prediction.details?.semanticAlignment,
          overallScore: prediction.details?.overall,
          sharedTerms: prediction.details?.sharedTerms || [],
        },
      },
    };
  })
);
```

### 4ï¸âƒ£ **Rendu des rÃ©sultats (ResultsPanel)**

#### **A. Calcul automatique des mÃ©triques**

```typescript
// ResultsPanel dÃ©tecte automatiquement le type de variable
const metricsType =
  targetKind === "M1" || targetKind === "M3" ? "numeric" : "classification";

// Pour M2: mÃ©triques de classification (distribution des alignements)
if (targetKind === "M2") {
  const distribution = {
    ALIGNEMENT_FORT: results.filter((r) => r.predicted === "ALIGNEMENT_FORT")
      .length,
    ALIGNEMENT_FAIBLE: results.filter(
      (r) => r.predicted === "ALIGNEMENT_FAIBLE"
    ).length,
    DESALIGNEMENT: results.filter((r) => r.predicted === "DESALIGNEMENT")
      .length,
  };
}
```

#### **B. Affichage du tableau unifiÃ©**

```typescript
// ResultsTableBody lit les champs standards pour toutes les variables
<TableRow>
  {/* Contexte conversationnel (4 lignes) */}
  <TableCell>
    T-2: {metadata.prev2_turn_verbatim || "â€”"}
    T-1: {metadata.prev1_turn_verbatim || "â€”"}
    T0: {verbatim} {/* â† Ligne principale */}
    T+1: {metadata.next_turn_verbatim || "â€”"}
  </TableCell>

  {/* Sortie algorithme */}
  <TableCell>{predicted}</TableCell>

  {/* RÃ©fÃ©rence (tag manuel du conseiller) */}
  <TableCell>{goldStandard}</TableCell>

  {/* Colonnes communes */}
  <TableCell>{confidence}</TableCell>
  <TableCell>{processingTime}ms</TableCell>

  {/* Bouton Annotations */}
  <TableCell>
    <AnnotationList turnId={metadata.turnId} />
  </TableCell>

  {/* Colonnes spÃ©cifiques M2 */}
  {extraColumns.map((col) => (
    <TableCell key={col.id}>
      {col.render(result)} {/* Ex: metadata.m2.lexicalScore */}
    </TableCell>
  ))}
</TableRow>
```

## ğŸ”§ Points techniques critiques

### **Registry unifiÃ©**

```typescript
// Tous les algorithmes sont enregistrÃ©s avec target
const M2CompositeAlignment = createUniversalAlgorithm(
  new M2CompositeAlignmentCalculator(),
  "M2", // â† target utilisÃ© pour le filtrage
  { displayName: "M2 Composite Alignment" }
);

algorithmRegistry.register("M2CompositeAlignment", M2CompositeAlignment);
```

### **DÃ©tection automatique du target**

```typescript
const getClassificationTarget = (classifierName) => {
  const algo = algorithmRegistry.get(classifierName);
  const target = algo?.describe?.()?.target; // "M2"

  if (target === "M2") return "M2";
  // Retourne: "conseiller" | "client" | "M1" | "M2" | "M3"
};
```

### **Colonnes dynamiques par variable**

```typescript
// buildExtraColumnsForTarget("M2")
const extraColumns = [
  {
    id: "lexical",
    header: "Score lexical",
    render: (row) => row.metadata?.m2?.lexicalScore?.toFixed(2) || "â€”",
  },
  {
    id: "semantic",
    header: "Score sÃ©mantique",
    render: (row) => row.metadata?.m2?.semanticScore?.toFixed(2) || "â€”",
  },
  {
    id: "sharedTerms",
    header: "Termes partagÃ©s",
    render: (row) => row.metadata?.m2?.sharedTerms?.join(", ") || "â€”",
  },
];
```

## âœ… Avantages du pattern unifiÃ©

1. **Une seule source de donnÃ©es** : `TaggingDataContext`
2. **Un seul hook de test** : `useLevel1Testing`
3. **Un seul format de rÃ©sultats** : `TVValidationResult`
4. **Une seule table** : `ResultsTableBody`
5. **Registry centralisÃ©** : `algorithmRegistry`
6. **Filtrage automatique** : selon `algorithm.target`
7. **Contexte conversationnel automatique** : T-2/T-1/T0/T+1
8. **MÃ©tadonnÃ©es enrichies** : annotations, IDs, infos algorithme

## ğŸš¨ Pattern Ã  suivre pour M2

```typescript
// âŒ Ã‰VITER : Hook isolÃ© avec donnÃ©es factices
const useM2AlgorithmTesting = () => {
  const seed = [
    /* donnÃ©es factices */
  ];
  // ...
};

// âœ… UTILISER : Hook unifiÃ© avec donnÃ©es rÃ©elles
const M2ValidationInterface = () => {
  const { validateAlgorithm } = useLevel1Testing();

  const runTest = useCallback(
    async (sampleSize) => {
      const results = await validateAlgorithm(
        "M2CompositeAlignment",
        sampleSize
      );
      // Les rÃ©sultats sont automatiquement formatÃ©s pour la table
    },
    [validateAlgorithm]
  );
};
```

---

**ğŸ¯ RÃ©sultat** : M2 suit exactement le mÃªme flux que M1, avec des donnÃ©es rÃ©elles, un contexte conversationnel complet, et un affichage unifiÃ© dans la table commune.
