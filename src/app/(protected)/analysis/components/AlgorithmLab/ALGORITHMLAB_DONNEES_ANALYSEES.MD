je voudrais normaliser les traitements entre les algorithmes des donn√©es X, Y, M1, M2, M3, j'ai deja centralis√© les types et les intefaces, mais je m'aper√ßois qu'il y a encore des traitements diff√©renci√©s dans le chargement des donn√©es pour les algo X, Y M1 ,M2

les donn√©es a analyser sont issus de la table turntagged

### Database Tables

### turntagged

[](https://supabase.com/dashboard/project/jregkxiwrnquslbocicz/database/tables)[ ]

New column

| Name               | Description    | Data Type                     | Format      | Nullable |     |
| ------------------ | -------------- | ----------------------------- | ----------- | -------- | --- |
| id                 | No description | `integer`                     | `int4`      |          |     |
| call_id            | No description | `integer`                     | `int4`      |          |     |
| start_time         | No description | `double precision`            | `float8`    |          |     |
| end_time           | No description | `double precision`            | `float8`    |          |     |
| tag                | No description | `text`                        | `text`      |          |     |
| verbatim           | No description | `text`                        | `text`      |          |     |
| date               | No description | `timestamp without time zone` | `timestamp` |          |     |
| next_turn_tag      | No description | `text`                        | `text`      |          |     |
| next_turn_verbatim | No description | `text`                        | `text`      |          |     |
| speaker            | No description | `text`                        | `text`      |          |     |
| next_turn_tag_auto | No description | `text`                        | `text`      |          |     |
| score_auto         | No description | `numeric`                     | `numeric`   |          |     |
| annotations        | No description | `jsonb`                       | `jsonb`     |          |     |

le corpus a analyser est toujours le meme: les tour de parole conseiller suiv par un tour de parole client

on d√©fini un tour de parole conseiller si son tag appartient √† l'une des familles REFLET, OUVERTURE, EXPLICATION, ENGAGEMENT

les familles sont d√©finies dans la table lpltag

### Database Tables

### lpltag

[](https://supabase.com/dashboard/project/jregkxiwrnquslbocicz/database/tables)[ ]

New column

| Name           | Description                                           | Data Type                     | Format      | Nullable |     |
| -------------- | ----------------------------------------------------- | ----------------------------- | ----------- | -------- | --- |
| id             | No description                                        | `integer`                     | `int4`      |          |     |
| label          | No description                                        | `text`                        | `text`      |          |     |
| description    | No description                                        | `text`                        | `text`      |          |     |
| family         | No description                                        | `text`                        | `text`      |          |     |
| color          | No description                                        | `text`                        | `text`      |          |     |
| created_at     | No description                                        | `timestamp without time zone` | `timestamp` |          |     |
| icon           | No description                                        | `text`                        | `text`      |          |     |
| originespeaker | Indique si le tag provient du client ou du conseiller | `text`                        | `text`      |          |     |

on d√©fini un tour de parole client si son tag appartient √† CLIENT POSITIF, CLIENT NEGATIF, CLIENT NEUTRE ou les orthographes equivalentes

dans turntagged, le next turn est cr√©√©/mis a jour par la fonction

constcalculateAllNextTurnTags=useCallback(

    async (callId:string):Promise`<number>` => {

    if (!supabase) {

    console.warn("Supabase not available");

    return0;

    }

    try {

    console.log("=== CALCUL NEXT_TURN_TAG SIMPLIFI√â ===");

    console.log("Call ID:", callId);

    // 1. R√©cup√©rer les tags valides de lpltag

    const { data: validTags, error: validTagsError } =awaitsupabase

    .from("lpltag")

    .select("label")

    .not("label", "is", null);

    if (validTagsError) {

    console.error("Erreur r√©cup√©ration tags valides:", validTagsError);

    return0;

    }

    constvalidTagLabels=newSet(

    validTags?.map((tag) =>tag.label) || []

    );

    console.log(`üìã ${validTagLabels.size} tags valides dans lpltag`);

    // 2. R√©cup√©rer TOUS les tags tri√©s par temps (ordre chronologique strict)

    const { data: allTags, error: tagsError } =awaitsupabase

    .from("turntagged")

    .select("id, start_time, end_time, tag, speaker, next_turn_tag")

    .eq("call_id", callId)

    .order("start_time", { ascending:true })

    .order("id", { ascending:true }); // Tri secondaire pour stabilit√©

    if (tagsError) {

    console.error("Erreur r√©cup√©ration tags:", tagsError);

    return0;

    }

    if (!allTags||allTags.length===0) {

    console.log("Aucun tag trouv√© pour cet appel");

    return0;

    }

    console.log(`Traitement de ${allTags.length} tags`);

    letupdatedCount=0;

    letrejectedCount=0;

    // 3. ‚úÖ LOGIQUE SIMPLE : pour chaque tag, trouver le prochain tag d'un speaker diff√©rent

    for (leti=0; i<allTags.length; i++) {

    constcurrentTag=allTags[i];

    console.log(

    `\nüîç Tag${i + 1}/${allTags.length}: ${currentTag.id} (${

    currentTag.start_time

    }s) -${currentTag.tag} [${currentTag.speaker}]`

    );

    // Chercher le PROCHAIN tag d'un speaker diff√©rent

    letnextTurnTag=null;

    letnextTagFound=null;

    for (letj=i+1; j<allTags.length; j++) {

    constcandidateTag=allTags[j];

    // ‚úÖ CONDITION SIMPLE : speaker diff√©rent

    if (candidateTag.speaker!==currentTag.speaker) {

    console.log(

    `   ‚Üí Candidat trouv√©: ${candidateTag.id} (${candidateTag.start_time}s) - ${candidateTag.tag} [${candidateTag.speaker}]`

    );

    // Valider que le tag existe dans lpltag

    if (validTagLabels.has(candidateTag.tag)) {

    nextTurnTag=candidateTag.tag;

    nextTagFound=candidateTag;

    console.log(`   ‚úÖ Next turn valid√©: "${nextTurnTag}"`);

    break; // Prendre le PREMIER trouv√© (le plus proche chronologiquement)

    } else {

    console.log(

    `   üö´ Tag "${candidateTag.tag}" rejet√© (pas dans lpltag)`

    );

    rejectedCount++;

    }

    }

    }

    if (!nextTagFound) {

    console.log(

    `   ‚ùå Aucun next turn trouv√© (fin de conversation ou m√™me speaker)`

    );

    }

    // 4. Mettre √† jour SEULEMENT si diff√©rent de l'existant

    if (currentTag.next_turn_tag!==nextTurnTag) {

    console.log(

    `   üîÑ Mise √† jour: "${currentTag.next_turn_tag}" ‚Üí "${nextTurnTag}"`

    );

    const { error: updateError } =awaitsupabase

    .from("turntagged")

    .update({ next_turn_tag:nextTurnTag })

    .eq("id", currentTag.id);

    if (updateError) {

    console.error(

    `   ‚ùå Erreur mise √† jour tag ${currentTag.id}:`,

    updateError

    );

    } else {

    console.log(`   ‚úÖ Tag ${currentTag.id} mis √† jour avec succ√®s`);

    updatedCount++;

    }

    } else {

    console.log(`   ‚è∏Ô∏è Pas de changement n√©cessaire`);

    }

    }

    console.log(`\n=== R√âSULTATS FINAUX ===`);

    console.log(`‚úÖ ${updatedCount} tags mis √† jour`);

    console.log(`üö´ ${rejectedCount} tags rejet√©s (invalides)`);

    console.log(`‚è∏Ô∏è ${allTags.length - updatedCount} tags inchang√©s`);

    // 5. Rafra√Æchir l'√©tat local si des changements

    if (updatedCount>0) {

    console.log("üîÑ Rafra√Æchissement de l'√©tat local...");

    awaitfetchTaggedTurns(callId);

    }

    returnupdatedCount;

    } catch (err) {

    console.error("‚ùå Erreur dans calculateAllNextTurnTags:", err);

    return0;

    }

    },

    [supabase, fetchTaggedTurns]

); dans TggingDataContext. Quand on utilise AlgorithmLab le corpus est dans Turntagged et il faut extraire toujours le meme corpus d√©fini pr√©c√©demment, certains algo vont partir du tour conseiller comme X, M1 , M2 et certains vont partir du tour clientcomme Y et M3 comme on le verra plus tard. ValidateAlgorithm dans useLevel1Testin va orienter vers le bon algo mais on part toujours du meme corpus filtr√© de turntagged, cette partie semble mal mutualis√©e entre les algo

Je voudrais donc faire un audit de la situation, dis moi si tu as besoin de code
