# üîß Plan de normalisation COMPLET du chargement de corpus AlgorithmLab (V2)

## üéØ Objectif

**SUPPRIMER** tous les hooks sp√©cialis√©s (useXAlgorithmTesting, useM1AlgorithmTesting, useM2AlgorithmTesting, useM3AlgorithmTesting) et **UNIFORMISER** sur le pattern Y ‚Üí BaseAlgorithmTesting ‚Üí useLevel1Testing.

## üìä Situation actuelle PROBL√âMATIQUE

### ‚ùå Hooks sp√©cialis√©s √† SUPPRIMER

| Hook                    | Probl√®mes identifi√©s                                     | Lignes de code |
| ----------------------- | -------------------------------------------------------- | -------------- |
| `useXAlgorithmTesting`  | 400+ lignes, logique complexe isol√©e, donn√©es mock       | ~430           |
| `useM1AlgorithmTesting` | Logique isol√©e, format sp√©cifique                        | ~50            |
| `useM2AlgorithmTesting` | **DONN√âES FACTICES** , pas les vraies donn√©es turntagged | ~120           |
| `useM3AlgorithmTesting` | Logique isol√©e, format sp√©cifique                        | ~80            |

### ‚úÖ R√©f√©rence CORRECTE √† suivre

**Y** utilise le pattern unifi√© :

```typescript
// YValidationInterface.tsx
<BaseAlgorithmTesting
  variableLabel="Y ‚Äî R√©actions Client"
  defaultClassifier="RegexYClassifier"
  target="Y"
/>
```

## üéØ DISTINCTION FONDAMENTALE : CIBLES vs MOYENS

### **CIBLES (ce qu'on veut mesurer)**

- **X** : Tagger le tour conseiller
- **Y** : Tagger le tour client
- **M1** : Densit√© verbes d'action dans le tour conseiller
- **M2** : Alignement entre tour conseiller ‚Üî tour client
- **M3** : Charge cognitive du tour client

### **MOYENS (donn√©es utilis√©es par les algorithmes)**

Selon l'algorithme, il peut utiliser :

- **Seulement le tour cible** (T0)
- **Tour + tour suivant** (T0 + T+1)
- **Contexte 2 tours pr√©c√©dents** (T-2, T-1, T0)
- **Contexte √©tendu** (T-2, T-1, T0, T+1)

## üìä **INVENTAIRE COMPLET DES ALGORITHMES**

### **üéØ Variable X (Strat√©gies Conseiller)**

| **Algorithme**        | **Contexte utilis√©** | **Format d'input**         | **Type**   |
| --------------------- | -------------------- | -------------------------- | ---------- |
| `RegexXClassifier`    | T0 seulement         | `string`                   | rule-based |
| `OpenAIXClassifier`   | T0 seulement         | `string`                   | llm        |
| `OpenAI3TXClassifier` | T-2, T-1, T0         | `string`(contexte 3 tours) | llm        |
| `SpacyXClassifier`    | T0 seulement         | `string`                   | ml         |

### **üéØ Variable Y (R√©actions Client)**

| **Algorithme**     | **Contexte utilis√©** | **Format d'input** | **Type**   |
| ------------------ | -------------------- | ------------------ | ---------- |
| `RegexYClassifier` | T0 seulement         | `string`           | rule-based |

### **üéØ Variable M1 (Densit√© verbes d'action)**

| **Algorithme**        | **Contexte utilis√©** | **Format d'input** | **Type**   |
| --------------------- | -------------------- | ------------------ | ---------- |
| `RegexM1Calculator`   | T0 seulement         | `string`           | rule-based |
| `M1ActionVerbCounter` | T0 seulement         | `string`           | rule-based |

### **üéØ Variable M2 (Alignement T0 ‚Üî T+1)**

| **Algorithme**                   | **Contexte utilis√©** | **Format d'input**       | **Type**   |
| -------------------------------- | -------------------- | ------------------------ | ---------- |
| `M2LexicalAlignmentCalculator`   | T0 + T+1             | `{t0, t1}`               | rule-based |
| `M2SemanticAlignmentCalculator`  | T0 + T+1             | `{t0, t1}`               | rule-based |
| `M2CompositeAlignmentCalculator` | T0 + T+1 + contexte  | `{t0, t1, prev1, prev2}` | hybrid     |

### **üéØ Variable M3 (Charge cognitive client)**

| **Algorithme**       | **Contexte utilis√©** | **Format d'input**  | **Type**   |
| -------------------- | -------------------- | ------------------- | ---------- |
| `PausesM3Calculator` | T0 seulement         | `M3Input {segment}` | rule-based |

## üîÑ SOLUTION : Migration vers pattern unifi√©

### √âtape 1: Configuration centralis√©e par algorithme

```typescript
// shared/algorithmConfig.ts - NOUVEAU FICHIER CRITIQUE
export interface AlgorithmConfig {
  target: VariableTarget;
  speakerType: "conseiller" | "client";
  inputFormat:
    | "simple"
    | "contextual"
    | "alignment"
    | "alignment_context"
    | "cognitive";
  requiresNextTurn: boolean;
  requiresPrevContext: boolean;
}

// ‚úÖ BONNE APPROCHE (par algorithme, pas par target)
export const ALGORITHM_CONFIGS: Record<string, AlgorithmConfig> = {
  // === VARIABLE X ===
  RegexXClassifier: {
    target: "X",
    speakerType: "conseiller",
    inputFormat: "simple", // string simple
    requiresNextTurn: false,
    requiresPrevContext: false,
  },
  OpenAIXClassifier: {
    target: "X",
    speakerType: "conseiller",
    inputFormat: "simple", // string simple
    requiresNextTurn: false,
    requiresPrevContext: false,
  },
  OpenAI3TXClassifier: {
    target: "X",
    speakerType: "conseiller",
    inputFormat: "contextual", // string avec contexte 3 tours
    requiresNextTurn: false,
    requiresPrevContext: true, // ‚úÖ UTILISE T-2, T-1, T0
  },
  SpacyXClassifier: {
    target: "X",
    speakerType: "conseiller",
    inputFormat: "simple", // string simple
    requiresNextTurn: false,
    requiresPrevContext: false,
  },

  // === VARIABLE Y ===
  RegexYClassifier: {
    target: "Y",
    speakerType: "client",
    inputFormat: "simple", // string simple
    requiresNextTurn: false,
    requiresPrevContext: false, // Y peut utiliser contexte conseiller pr√©c√©dent
  },

  // === VARIABLE M1 ===
  RegexM1Calculator: {
    target: "M1",
    speakerType: "conseiller",
    inputFormat: "simple", // string simple
    requiresNextTurn: false,
    requiresPrevContext: false,
  },
  M1ActionVerbCounter: {
    target: "M1",
    speakerType: "conseiller",
    inputFormat: "simple", // string simple
    requiresNextTurn: false,
    requiresPrevContext: false,
  },

  // === VARIABLE M2 ===
  M2LexicalAlignmentCalculator: {
    target: "M2",
    speakerType: "conseiller", // Part du conseiller
    inputFormat: "alignment", // {t0, t1}
    requiresNextTurn: true, // ‚úÖ OBLIGATOIRE pour M2
    requiresPrevContext: false,
  },
  M2SemanticAlignmentCalculator: {
    target: "M2",
    speakerType: "conseiller",
    inputFormat: "alignment", // {t0, t1}
    requiresNextTurn: true, // ‚úÖ OBLIGATOIRE pour M2
    requiresPrevContext: false,
  },
  M2CompositeAlignmentCalculator: {
    target: "M2",
    speakerType: "conseiller",
    inputFormat: "alignment_context", // {t0, t1, prev1, prev2}
    requiresNextTurn: true, // ‚úÖ OBLIGATOIRE pour M2
    requiresPrevContext: true, // ‚úÖ UTILISE contexte √©tendu
  },

  // === VARIABLE M3 ===
  PausesM3Calculator: {
    target: "M3",
    speakerType: "client",
    inputFormat: "cognitive", // M3Input {segment, options}
    requiresNextTurn: false,
    requiresPrevContext: true, // M3 peut utiliser contexte conseiller
  },
};
```

### √âtape 2: Fonctions utilitaires centralis√©es

```typescript
// shared/corpusFilters.ts
export const filterCorpusForAlgorithm = (
  goldStandardData: TVGoldStandardSample[],
  algorithmName: string
): TVGoldStandardSample[] => {
  const config = ALGORITHM_CONFIGS[algorithmName];
  if (!config) {
    console.warn(`No config found for algorithm: ${algorithmName}`);
    return goldStandardData;
  }

  let filtered = goldStandardData;

  // 1. Filtre par type de speaker
  filtered = filtered.filter((sample) => {
    if (config.speakerType === "conseiller") {
      return (
        sample.metadata?.target === "conseiller" &&
        allowedConseiller.includes(sample.expectedTag)
      );
    } else {
      return (
        sample.metadata?.target === "client" &&
        allowedClient.includes(sample.expectedTag)
      );
    }
  });

  // 2. Filtre : n√©cessite next_turn_verbatim (M2, certains X)
  if (config.requiresNextTurn) {
    filtered = filtered.filter((s) => s.metadata?.next_turn_verbatim);
  }

  // 3. Filtre : n√©cessite contexte pr√©c√©dent (OpenAI3TXClassifier, M3, M2Composite)
  if (config.requiresPrevContext) {
    filtered = filtered.filter(
      (s) => s.metadata?.prev1_turn_verbatim || s.metadata?.prev2_turn_verbatim
    );
  }

  return filtered;
};

// shared/inputPreparation.ts
export const prepareInputsForAlgorithm = (
  samples: TVGoldStandardSample[],
  algorithmName: string
): any[] => {
  const config = ALGORITHM_CONFIGS[algorithmName];
  if (!config) throw new Error(`Algorithm ${algorithmName} not configured`);

  return samples.map((sample) => {
    switch (config.inputFormat) {
      case "simple":
        // X (la plupart), Y, M1 (tous) : verbatim direct
        return sample.verbatim;

      case "contextual":
        // OpenAI3TXClassifier : contexte 3 tours
        return {
          current: sample.verbatim,
          prev1: sample.metadata?.prev1_turn_verbatim,
          prev2: sample.metadata?.prev2_turn_verbatim,
          context: `${sample.metadata?.prev2_turn_verbatim || ""} ${
            sample.metadata?.prev1_turn_verbatim || ""
          } ${sample.verbatim}`.trim(),
        };

      case "alignment":
        // M2 Lexical/Semantic : format basique
        return {
          t0: sample.verbatim,
          t1: sample.metadata?.next_turn_verbatim,
        };

      case "alignment_context":
        // M2 Composite : format √©tendu
        return {
          t0: sample.verbatim,
          t1: sample.metadata?.next_turn_verbatim,
          prev1: sample.metadata?.prev1_turn_verbatim,
          prev2: sample.metadata?.prev2_turn_verbatim,
          conseillerTurn: sample.verbatim,
          clientTurn: sample.metadata?.next_turn_verbatim,
        };

      case "cognitive":
        // M3 : format charge cognitive
        return {
          segment: sample.verbatim,
          withProsody: false,
          language: "fr",
          options: {
            id: sample.metadata?.turnId,
            clientTurn: sample.verbatim,
            conseillerContext: sample.metadata?.prev1_turn_verbatim,
          },
        };

      default:
        return sample.verbatim;
    }
  });
};
```

### √âtape 3: Compl√©ter useLevel1Testing

```typescript
// useLevel1Testing.ts - Hook unifi√© (√† compl√©ter)
export const useLevel1Testing = () => {
  const { allTurnTagged } = useTaggingData();

  // ‚úÖ D√âJ√Ä EN PLACE : Mapping centralis√© des donn√©es r√©elles
  const goldStandardData = useMemo(
    () => mapTurnsToGoldStandard(allTurnTagged, allowedConseiller),
    [allTurnTagged, allowedConseiller]
  );

  // üîß √Ä IMPL√âMENTER : Logique de validation unifi√©e par algorithme
  const validateAlgorithm = useCallback(
    async (algorithmName: string, sampleSize: number) => {
      const algorithm = algorithmRegistry.get(algorithmName);
      if (!algorithm) throw new Error(`Algorithm ${algorithmName} not found`);

      // 1. FILTRAGE UNIFI√â selon l'algorithme
      const filteredBase = filterCorpusForAlgorithm(
        goldStandardData,
        algorithmName
      );

      // 2. √âCHANTILLONNAGE
      const samples = randomSample(filteredBase, sampleSize);

      // 3. PR√âPARATION UNIFI√âE des inputs selon l'algorithme
      const inputs = prepareInputsForAlgorithm(samples, algorithmName);

      // 4. EX√âCUTION et formatage des r√©sultats
      const results = await Promise.all(
        inputs.map(async (input, i) => {
          const sample = samples[i];
          const prediction = await algorithm.run(input);
          return formatResultForAlgorithm(sample, prediction, algorithmName);
        })
      );

      return results;
    },
    [goldStandardData]
  );

  return { validateAlgorithm, goldStandardData };
};
```

### √âtape 4: Migration des interfaces

#### AVANT (probl√©matique)

```typescript
// XValidationInterface.tsx - AVANT
import XAlgorithmTesting from "./XAlgorithmTesting";
export default function XValidationInterface() {
  return <XAlgorithmTesting />; // ‚ùå Hook isol√©
}

// M1ValidationInterface.tsx - AVANT
import M1AlgorithmTesting from "./M1AlgorithmTesting";
export default function M1ValidationInterface() {
  return <M1AlgorithmTesting />; // ‚ùå Hook isol√©
}
```

#### APR√àS (unifi√©)

```typescript
// XValidationInterface.tsx - APR√àS
import { BaseAlgorithmTesting } from "../BaseAlgorithmTesting";
export default function XValidationInterface() {
  return (
    <BaseAlgorithmTesting
      variableLabel="X ‚Äî Strat√©gies Conseiller"
      defaultClassifier="RegexXClassifier"
      target="X" // ‚Üê Auto-filtre les algorithmes X
      availableAlgorithms={[
        "RegexXClassifier",
        "OpenAIXClassifier",
        "OpenAI3TXClassifier",
        "SpacyXClassifier",
      ]}
    />
  );
}

// M1ValidationInterface.tsx - APR√àS
import { BaseAlgorithmTesting } from "../BaseAlgorithmTesting";
export default function M1ValidationInterface() {
  return (
    <BaseAlgorithmTesting
      variableLabel="M1 ‚Äî Densit√© de verbes d'action"
      defaultClassifier="RegexM1Calculator"
      target="M1"
      availableAlgorithms={["RegexM1Calculator", "M1ActionVerbCounter"]}
    />
  );
}

// M2ValidationInterface.tsx - APR√àS (FIX CRITIQUE)
import { BaseAlgorithmTesting } from "../BaseAlgorithmTesting";
export default function M2ValidationInterface() {
  return (
    <BaseAlgorithmTesting
      variableLabel="M2 ‚Äî Alignement conseiller ‚Üî client"
      defaultClassifier="M2CompositeAlignmentCalculator"
      target="M2"
      availableAlgorithms={[
        "M2CompositeAlignmentCalculator",
        "M2LexicalAlignmentCalculator",
        "M2SemanticAlignmentCalculator",
      ]}
      // ‚ùå SUPPRIME les donn√©es factices
      // ‚úÖ UTILISE les vraies donn√©es via useLevel1Testing
    />
  );
}

// M3ValidationInterface.tsx - APR√àS
import { BaseAlgorithmTesting } from "../BaseAlgorithmTesting";
export default function M3ValidationInterface() {
  return (
    <BaseAlgorithmTesting
      variableLabel="M3 ‚Äî Charge cognitive client"
      defaultClassifier="PausesM3Calculator"
      target="M3"
      availableAlgorithms={["PausesM3Calculator"]}
    />
  );
}
```

## üóëÔ∏è FICHIERS √Ä SUPPRIMER

```bash
# Hooks sp√©cialis√©s √† SUPPRIMER compl√®tement
rm src/hooks/level1/useXAlgorithmTesting.ts      # ~430 lignes
rm src/hooks/level1/useM1AlgorithmTesting.ts     # ~50 lignes
rm src/hooks/level1/useM2AlgorithmTesting.ts     # ~120 lignes (DONN√âES FACTICES)
rm src/hooks/level1/useM3AlgorithmTesting.ts     # ~80 lignes

# Composants de test sp√©cialis√©s √† SUPPRIMER
rm src/components/Level1/algorithms/XClassifiers/XAlgorithmTesting.tsx
rm src/components/Level1/algorithms/M1Calculators/M1AlgorithmTesting.tsx
rm src/components/Level1/algorithms/M2Calculators/M2AlgorithmTesting.tsx
rm src/components/Level1/algorithms/M3Calculators/M3AlgorithmTesting.tsx

# TOTAL : ~680 lignes de code supprim√©es + maintenance simplifi√©e
```

## üöÄ Plan d'impl√©mentation R√âVIS√â

### Phase 1: Pr√©paratifs (1-2h)

1. ‚úÖ Documenter l'existant (fait)
2. Cr√©er `shared/algorithmConfig.ts` avec `ALGORITHM_CONFIGS`
3. Cr√©er `shared/corpusFilters.ts` avec `filterCorpusForAlgorithm`
4. Cr√©er `shared/inputPreparation.ts` avec `prepareInputsForAlgorithm`

### Phase 2: Compl√©ter useLevel1Testing (2-3h)

1. Impl√©menter `validateAlgorithm` avec logique par algorithme
2. Impl√©menter `formatResultForAlgorithm`
3. Tester avec Y (r√©f√©rence)
4. Tester avec M2 sur vraies donn√©es (PRIORIT√â)

### Phase 3: Migration progressive (3-4h)

1. **X** : Migrer vers BaseAlgorithmTesting
2. **M1** : Migrer vers BaseAlgorithmTesting
3. **M2** : Corriger pour utiliser vraies donn√©es (CRITIQUE)
4. **M3** : Migrer vers BaseAlgorithmTesting

### Phase 4: Nettoyage (1h)

1. Supprimer tous les hooks sp√©cialis√©s
2. Supprimer les composants de test sp√©cialis√©s
3. Tests de non-r√©gression
4. Documentation

## ‚úÖ R√©sultat final

**AVANT** : 5 syst√®mes diff√©rents, ~680 lignes de code dupliqu√©, donn√©es factices
**APR√àS** : 1 syst√®me unifi√©, donn√©es r√©elles partout, maintenance simplifi√©e

### Architecture cible unifi√©e

```
Level1Interface
‚îú‚îÄ‚îÄ XValidationInterface ‚Üí BaseAlgorithmTesting(target="X")
‚îú‚îÄ‚îÄ YValidationInterface ‚Üí BaseAlgorithmTesting(target="Y") ‚úÖ D√âJ√Ä OK
‚îú‚îÄ‚îÄ M1ValidationInterface ‚Üí BaseAlgorithmTesting(target="M1")
‚îú‚îÄ‚îÄ M2ValidationInterface ‚Üí BaseAlgorithmTesting(target="M2")
‚îî‚îÄ‚îÄ M3ValidationInterface ‚Üí BaseAlgorithmTesting(target="M3")

Tous utilisent:
‚îú‚îÄ‚îÄ useLevel1Testing (hook unifi√©)
‚îú‚îÄ‚îÄ mapTurnsToGoldStandard (donn√©es r√©elles)
‚îú‚îÄ‚îÄ algorithmRegistry (algorithmes centralis√©s)
‚îú‚îÄ‚îÄ ALGORITHM_CONFIGS (configuration par algorithme)
‚îú‚îÄ‚îÄ filterCorpusForAlgorithm (filtrage intelligent)
‚îî‚îÄ‚îÄ prepareInputsForAlgorithm (pr√©paration automatique)
```

### Avantages imm√©diats

1. **680+ lignes supprim√©es**
2. **Donn√©es r√©elles partout** (fin des mocks M2)
3. **1 seule logique** √† maintenir
4. **Configuration par algorithme** (flexibilit√© maximale)
5. **Comportement pr√©visible** et coh√©rent
6. **Tests simplifi√©s**
7. **Ajout d'algorithmes facilit√©**
8. **Distinction claire CIBLES vs MOYENS**

---

**üéØ PRIORIT√â 1 : Impl√©menter ALGORITHM_CONFIGS et les fonctions de filtrage/pr√©paration par algorithme**

**üéØ PRIORIT√â 2 : Corriger M2 pour utiliser les vraies donn√©es turntagged (plus de donn√©es factices)**
