# üìû Sp√©cifications du Workflow des Appels - Page /calls (MISE √Ä JOUR)

## üí° **NOUVELLES SP√âCIFICATIONS - ONGLET PR√âPARATION**

### üéØ **Modification majeure approuv√©e en session**

**Probl√®me identifi√©** : Dans l'ancienne version, le bouton "Pr√©parer" m√©langeait deux responsabilit√©s :

1. Compl√©ter l'appel avec fichiers manquants (audio/transcription)
2. Transformer techniquement JSONB ‚Üí tables `transcript`/`word`

**Solution** : S√©parer ces responsabilit√©s en deux colonnes distinctes.

## üîÑ **NOUVELLE ARCHITECTURE - S√âPARATION DES RESPONSABILIT√âS**

### **Colonne 1 : Actions de Compl√©ment**

- **But** : Compl√©ter l'appel avec les fichiers manquants
- **Boutons contextuels** :
  - üéµ **"Ajouter Audio"** (si `upload = false`)
  - üìù **"Ajouter Transcription"** (si `transcription = null`)
  - üëÅÔ∏è **"Voir Contenu"** (toujours disponible)

### **Colonne Actions : Pr√©paration Technique**

- **But** : Pr√©parer techniquement l'appel pour le tagging
- **Bouton** : üîß **"Pr√©parer pour Tagging"**
  - Transforme JSONB `call.transcription` ‚Üí tables `transcript` + `word`
  - Marque `preparedfortranscript = true`
  - **Condition** : Disponible seulement si `transcription ‚â† null`

## üé® **Interface Propos√©e - Table Pr√©paration**

```
‚îå‚îÄ Actions Compl√©ment ‚îÄ‚î¨‚îÄ √âtat ‚îÄ‚î¨‚îÄ Fichier ‚îÄ‚î¨‚îÄ Description ‚îÄ‚î¨‚îÄ Pr√©paration ‚îÄ‚îê
‚îÇ üéµ Ajouter Audio     ‚îÇüéµüìù    ‚îÇfile.mp3   ‚îÇ Description  ‚îÇ [Pr√©parer]   ‚îÇ
‚îÇ üìù Ajouter Transc.   ‚îÇComplet ‚îÇ           ‚îÇ              ‚îÇ              ‚îÇ
‚îÇ üëÅÔ∏è Voir Contenu      ‚îÇ        ‚îÇ           ‚îÇ              ‚îÇ              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ üéµ Ajouter Audio     ‚îÇüìù      ‚îÇfile.json  ‚îÇ Transcription‚îÇ [Pr√©parer]   ‚îÇ
‚îÇ üëÅÔ∏è Voir JSON         ‚îÇSeule   ‚îÇ           ‚îÇ seule        ‚îÇ              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ üëÅÔ∏è Voir Audio/JSON   ‚îÇ‚úÖ Pr√™t ‚îÇfile.mp3   ‚îÇ D√©j√† pr√©par√©‚îÇ [‚Üí Liste]    ‚îÇ
‚îÇ                     ‚îÇ        ‚îÇ           ‚îÇ              ‚îÇ              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üìä **√âtats des Appels et Actions Disponibles**

### **√âtat 1 : Audio seul**

```sql
upload = true, transcription = null, preparedfortranscript = false
```

- **Actions** : [üìù Ajouter Transcription] [üëÅÔ∏è Voir Audio]
- **Pr√©paration** : ‚ùå **Pas disponible** (transcription requise)

### **√âtat 2 : Transcription seule**

```sql
upload = false, transcription ‚â† null, preparedfortranscript = false
```

- **Actions** : [üéµ Ajouter Audio] [üëÅÔ∏è Voir JSON]
- **Pr√©paration** : ‚úÖ **[Pr√©parer pour Tagging]** disponible

### **√âtat 3 : Audio + Transcription (complet)**

```sql
upload = true, transcription ‚â† null, preparedfortranscript = false
```

- **Actions** : [üëÅÔ∏è Voir Audio] [üëÅÔ∏è Voir JSON]
- **Pr√©paration** : ‚úÖ **[Pr√©parer pour Tagging]** disponible

### **√âtat 4 : Pr√©par√© pour tagging**

```sql
preparedfortranscript = true
```

- **Actions** : [üëÅÔ∏è Voir] [üóëÔ∏è Supprimer]
- **Navigation** : ‚úÖ **[‚Üí Aller √† Liste]** (redirect vers onglet 2)

## üîß **Nouveau Modal Upload Audio Am√©lior√©**

### **Interface avec choix de source**

```typescript
interface AudioUploadModalProps {
  open: boolean;
  call?: Call;
  mode: "complement" | "preparation"; // Nouveau mode
  sources?: ("disk" | "workdrive")[]; // Sources disponibles
  onClose: () => void;
  onUpload: (file: File, call?: Call) => void;
}
```

### **Modal avec onglets**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üéµ Ajouter Audio - [Call #123]      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ [üíæ Disque Dur] [‚òÅÔ∏è WorkDrive]      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                     ‚îÇ
‚îÇ Onglet Disque Dur:                  ‚îÇ
‚îÇ [Parcourir...] [Glisser-d√©poser]    ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ OU                                  ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ Onglet WorkDrive:                   ‚îÇ
‚îÇ SimpleWorkdriveExplorer             ‚îÇ
‚îÇ (mode audioOnly=true)               ‚îÇ
‚îÇ                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ         [Annuler] [Ajouter]         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üîÑ **Workflow Mis √† Jour**

```mermaid
graph TD
    A[üì• Import WorkDrive] --> B[üîß Onglet Pr√©paration]
    B --> C{Audio manquant?}
    C -->|Oui| D[üéµ Ajouter Audio<br/>üíæ Disk ou ‚òÅÔ∏è WorkDrive]
    C -->|Non| E{Transcription manquante?}
    E -->|Oui| F[üìù Ajouter Transcription<br/>üíæ Disk ou ‚òÅÔ∏è WorkDrive]
    E -->|Non| G[üîß Pr√©parer pour Tagging]
    D --> G
    F --> G
    G --> H[üè∑Ô∏è Onglet Liste - Tagging]
```

## üõ†Ô∏è **MODIFICATIONS TECHNIQUES D√âTAILL√âES**

### **1. SimpleWorkdriveExplorer.tsx - Props √©tendues**

```typescript
// ‚úÖ MODIFICATION de l'interface existante
export interface SimpleWorkdriveExplorerProps {
  onFilesSelect: (audioFile: File | null, transcriptionText?: string) => void;
  rootFolderId?: string;
  // ‚úÖ NOUVELLES PROPS
  audioOnly?: boolean; // Filtre seulement les fichiers audio
  transcriptionOnly?: boolean; // Filtre seulement les transcriptions
  mode?: "full" | "audio_only" | "transcription_only"; // Mode d'utilisation
  showSelectionSummary?: boolean; // Afficher/masquer le r√©sum√© de s√©lection
  maxSelections?: {
    audio: number;
    transcription: number;
  };
}

// ‚úÖ MODIFICATION du composant principal
export default function SimpleWorkdriveExplorer({
  onFilesSelect,
  rootFolderId = ROOT_FOLDER_ID,
  audioOnly = false, // ‚úÖ NOUVEAU
  transcriptionOnly = false, // ‚úÖ NOUVEAU
  mode = "full", // ‚úÖ NOUVEAU
  showSelectionSummary = true, // ‚úÖ NOUVEAU
  maxSelections = { audio: 1, transcription: 1 }, // ‚úÖ NOUVEAU
}: SimpleWorkdriveExplorerProps) {
  // ... logique existante inchang√©e

  // ‚úÖ NOUVELLE LOGIQUE: Adaptation du comportement selon le mode
  useEffect(() => {
    // D√©sactiver la s√©lection selon le mode
    if (mode === "audio_only" || audioOnly) {
      setSelectedTranscriptionFile(null);
    }
    if (mode === "transcription_only" || transcriptionOnly) {
      setSelectedAudioFile(null);
    }
  }, [mode, audioOnly, transcriptionOnly]);

  // ‚úÖ MODIFICATION: Gestionnaires de s√©lection avec contr√¥les
  const handleSelectAudioFile = (file: ZohoFile) => {
    if (mode === "transcription_only" || transcriptionOnly) return;

    setSelectedAudioFile(selectedAudioFile?.id === file.id ? null : file);
  };

  const handleSelectTranscriptionFile = (file: ZohoFile) => {
    if (mode === "audio_only" || audioOnly) return;

    setSelectedTranscriptionFile(
      selectedTranscriptionFile?.id === file.id ? null : file
    );
  };

  // ‚úÖ MODIFICATION: Validation avant import
  const handleImportFiles = async () => {
    // Validation selon le mode
    if (mode === "audio_only" && !selectedAudioFile) {
      setError("Veuillez s√©lectionner un fichier audio");
      return;
    }
    if (mode === "transcription_only" && !selectedTranscriptionFile) {
      setError("Veuillez s√©lectionner une transcription");
      return;
    }
    if (mode === "full" && !selectedAudioFile && !selectedTranscriptionFile) {
      setError("Veuillez s√©lectionner au moins un fichier");
      return;
    }

    // ... logique d'import existante inchang√©e
  };

  // ‚úÖ NOUVEAU: Interface adapt√©e selon le mode
  const getTitle = () => {
    switch (mode) {
      case "audio_only":
        return "S√©lectionner un fichier audio";
      case "transcription_only":
        return "S√©lectionner une transcription";
      default:
        return "Import de nouveaux appels depuis Zoho WorkDrive";
    }
  };

  const getDescription = () => {
    switch (mode) {
      case "audio_only":
        return "Parcourez WorkDrive et s√©lectionnez un fichier audio √† ajouter.";
      case "transcription_only":
        return "Parcourez WorkDrive et s√©lectionnez une transcription √† ajouter.";
      default:
        return "Utilisez l'explorateur ci-dessous pour parcourir votre Zoho WorkDrive et importer directement vos fichiers audio et transcriptions.";
    }
  };

  return (
    <Box sx={{ width: "100%" }}>
      {/* ‚úÖ MODIFICATION: Titre et description adapt√©s */}
      {mode !== "full" && (
        <Box sx={{ mb: 2 }}>
          <Typography variant="h6" gutterBottom>
            {getTitle()}
          </Typography>
          <Typography variant="body2" color="textSecondary" paragraph>
            {getDescription()}
          </Typography>
        </Box>
      )}

      {/* ... Navigation et onglets inchang√©s ... */}

      {/* ‚úÖ MODIFICATION: R√©sum√© conditionnel */}
      {showSelectionSummary && (
        <FileSelectionSummary
          selectedAudioFile={selectedAudioFile}
          selectedTranscriptionFile={selectedTranscriptionFile}
          onClearAudioFile={() => setSelectedAudioFile(null)}
          onClearTranscriptionFile={() => setSelectedTranscriptionFile(null)}
          mode={mode} // ‚úÖ NOUVEAU prop
        />
      )}

      {/* ‚úÖ MODIFICATION: Bouton adapt√© selon le mode */}
      {(selectedAudioFile || selectedTranscriptionFile) && (
        <Paper
          elevation={2}
          sx={{ p: 2, mb: 2, bgcolor: "background.default" }}
        >
          <Button
            variant="contained"
            color="primary"
            onClick={handleImportFiles}
            disabled={processingImport}
            fullWidth
            sx={{ mt: 1 }}
          >
            {processingImport
              ? "S√©lection en cours..."
              : mode === "audio_only"
              ? "S√©lectionner cet audio"
              : mode === "transcription_only"
              ? "S√©lectionner cette transcription"
              : "Importer les fichiers s√©lectionn√©s"}
          </Button>
        </Paper>
      )}

      {/* ‚úÖ MODIFICATION: FileList avec filtrage */}
      {currentTab === 0 && (
        <FileList
          files={files}
          loading={loading}
          selectedAudioFile={selectedAudioFile}
          selectedTranscriptionFile={selectedTranscriptionFile}
          onFolderClick={handleFolderClick}
          onSelectAudioFile={handleSelectAudioFile}
          onSelectTranscriptionFile={handleSelectTranscriptionFile}
          mode={mode} // ‚úÖ NOUVEAU prop
        />
      )}

      {/* ‚úÖ MODIFICATION: SearchResults avec filtrage */}
      {currentTab === 1 && (
        <SearchResults
          searchResults={searchResults}
          selectedAudioFile={selectedAudioFile}
          selectedTranscriptionFile={selectedTranscriptionFile}
          onSelectAudioFile={handleSelectAudioFile}
          onSelectTranscriptionFile={handleSelectTranscriptionFile}
          allFiles={files}
          mode={mode} // ‚úÖ NOUVEAU prop
        />
      )}

      {/* ... Notifications inchang√©es ... */}
    </Box>
  );
}
```

### **2. FileList.tsx - Filtrage par mode**

```typescript
// ‚úÖ MODIFICATION de l'interface
interface FileListProps {
  files: ZohoFile[];
  loading: boolean;
  selectedAudioFile?: ZohoFile | null;
  selectedTranscriptionFile?: ZohoFile | null;
  onFolderClick: (folderId: string, folderName?: string) => void;
  onSelectAudioFile: (file: ZohoFile) => void;
  onSelectTranscriptionFile: (file: ZohoFile) => void;
  mode?: "full" | "audio_only" | "transcription_only"; // ‚úÖ NOUVEAU
}

export const FileList: React.FC<FileListProps> = ({
  files,
  loading,
  selectedAudioFile,
  selectedTranscriptionFile,
  onFolderClick,
  onSelectAudioFile,
  onSelectTranscriptionFile,
  mode = "full", // ‚úÖ NOUVEAU
}) => {
  // ‚úÖ NOUVEAU: Filtrage des fichiers selon le mode
  const filteredFiles = useMemo(() => {
    if (!files) return [];

    return files.filter((file) => {
      if (!file || !file.id) return false;

      // Toujours afficher les dossiers pour navigation
      const isFolder =
        file.attributes?.type === "folder" ||
        file.attributes?.is_folder === true;

      if (isFolder) return true;

      // Filtrage selon le mode
      if (mode === "audio_only") {
        return isAudioFile(file);
      }
      if (mode === "transcription_only") {
        return isTranscriptionFile(file);
      }

      // Mode 'full': afficher tous les fichiers
      return true;
    });
  }, [files, mode]);

  // ‚úÖ MODIFICATION: Utiliser filteredFiles au lieu de files
  return (
    <Box
      sx={{
        display: "grid",
        gridTemplateColumns: {
          xs: "1fr",
          sm: "repeat(2, 1fr)",
          md: "repeat(3, 1fr)",
        },
        gap: 2,
      }}
    >
      {filteredFiles.map((file) => {
        // ... logique existante inchang√©e pour le rendu des cartes

        return (
          <Card key={file.id} variant="outlined" /* ... styles ... */>
            <CardContent>
              {/* ... affichage existant inchang√© ... */}

              <Box
                sx={{ mt: 1, display: "flex", justifyContent: "space-between" }}
              >
                {isFolder ? (
                  <Button
                    size="small"
                    variant="outlined"
                    color="primary"
                    onClick={() => onFolderClick(file.id, fileName)}
                    fullWidth
                    startIcon={<FolderIcon />}
                  >
                    Ouvrir
                  </Button>
                ) : (
                  <Box
                    sx={{
                      display: "flex",
                      width: "100%",
                      justifyContent: "space-around",
                    }}
                  >
                    {/* ‚úÖ MODIFICATION: Boutons conditionnels selon le mode */}
                    {isAudio && (mode === "full" || mode === "audio_only") && (
                      <Button
                        size="small"
                        variant={
                          selectedAudioFile?.id === file.id
                            ? "contained"
                            : "outlined"
                        }
                        color="secondary"
                        onClick={() => onSelectAudioFile(file)}
                      >
                        {selectedAudioFile?.id === file.id
                          ? "Audio ‚úì"
                          : "S√©lect. Audio"}
                      </Button>
                    )}
                    {isTranscription &&
                      (mode === "full" || mode === "transcription_only") && (
                        <Button
                          size="small"
                          variant={
                            selectedTranscriptionFile?.id === file.id
                              ? "contained"
                              : "outlined"
                          }
                          color="primary"
                          onClick={() => onSelectTranscriptionFile(file)}
                        >
                          {selectedTranscriptionFile?.id === file.id
                            ? "Transcript. ‚úì"
                            : "S√©lect. Transcript."}
                        </Button>
                      )}
                  </Box>
                )}
              </Box>
            </CardContent>
          </Card>
        );
      })}
    </Box>
  );
};
```

### **3. FileSelectionSummary.tsx - Mode adaptatif**

```typescript
// ‚úÖ MODIFICATION de l'interface
interface FileSelectionSummaryProps {
  selectedAudioFile: ZohoFile | null;
  selectedTranscriptionFile: ZohoFile | null;
  onClearAudioFile: () => void;
  onClearTranscriptionFile: () => void;
  mode?: "full" | "audio_only" | "transcription_only"; // ‚úÖ NOUVEAU
}

export const FileSelectionSummary: React.FC<FileSelectionSummaryProps> = ({
  selectedAudioFile,
  selectedTranscriptionFile,
  onClearAudioFile,
  onClearTranscriptionFile,
  mode = "full", // ‚úÖ NOUVEAU
}) => {
  // ‚úÖ MODIFICATION: Affichage conditionnel selon le mode
  const shouldShowAudio =
    selectedAudioFile && (mode === "full" || mode === "audio_only");
  const shouldShowTranscription =
    selectedTranscriptionFile &&
    (mode === "full" || mode === "transcription_only");

  if (!shouldShowAudio && !shouldShowTranscription) {
    return null;
  }

  // ‚úÖ MODIFICATION: Titre adapt√© selon le mode
  const getTitle = () => {
    switch (mode) {
      case "audio_only":
        return "Fichier audio s√©lectionn√©:";
      case "transcription_only":
        return "Transcription s√©lectionn√©e:";
      default:
        return "Fichiers s√©lectionn√©s:";
    }
  };

  return (
    <Paper sx={{ p: 2, mb: 3 }}>
      <Typography variant="subtitle1" gutterBottom>
        {getTitle()}
      </Typography>
      <Box sx={{ display: "flex", flexWrap: "wrap", gap: 1 }}>
        {shouldShowAudio && (
          <Chip
            icon={<AudioFileIcon />}
            label={`Audio: ${getFileName(selectedAudioFile)}`}
            color="secondary"
            onDelete={onClearAudioFile}
          />
        )}
        {shouldShowTranscription && (
          <Chip
            icon={<DescriptionIcon />}
            label={`Transcription: ${getFileName(selectedTranscriptionFile)}`}
            color="primary"
            onDelete={onClearTranscriptionFile}
          />
        )}
      </Box>
    </Paper>
  );
};
```

### **4. SearchResults.tsx - Filtrage adaptatif**

```typescript
// ‚úÖ MODIFICATION: M√™me logique de filtrage que FileList
interface SearchResultsProps {
  searchResults: SearchResult;
  selectedAudioFile: ZohoFile | null;
  selectedTranscriptionFile: ZohoFile | null;
  onSelectAudioFile: (file: ZohoFile) => void;
  onSelectTranscriptionFile: (file: ZohoFile) => void;
  allFiles: ZohoFile[];
  mode?: "full" | "audio_only" | "transcription_only"; // ‚úÖ NOUVEAU
}

// Dans le composant, appliquer le m√™me filtrage que FileList
const filteredSearchResults = useMemo(() => {
  if (!searchResults.files) return [];

  return searchResults.files.filter((file) => {
    if (mode === "audio_only") return isAudioFile(file);
    if (mode === "transcription_only") return isTranscriptionFile(file);
    return true;
  });
}, [searchResults.files, mode]);
```

## üîß **UTILISATION DANS LE MODAL AUDIO**

### **AudioUploadModal.tsx - Int√©gration compl√®te**

```typescript
const AudioUploadModal: React.FC<AudioUploadModalProps> = ({
  open,
  call,
  mode,
  sources = ["disk", "workdrive"],
  onClose,
  onUpload,
}) => {
  const [activeTab, setActiveTab] = useState(0);

  // ‚úÖ Callback pour SimpleWorkdriveExplorer
  const handleWorkdriveSelection = (
    audioFile: File | null,
    transcriptionText?: string
  ) => {
    if (audioFile && call) {
      onUpload(audioFile, call);
      onClose(); // Fermer le modal apr√®s s√©lection
    }
  };

  return (
    <Dialog open={open} onClose={onClose} maxWidth="lg" fullWidth>
      <DialogTitle>
        üéµ Ajouter Audio {call && `- Appel #${call.callid}`}
      </DialogTitle>
      <DialogContent>
        <Tabs value={activeTab} onChange={(e, v) => setActiveTab(v)}>
          {sources.includes("disk") && <Tab label="üíæ Disque Dur" />}
          {sources.includes("workdrive") && <Tab label="‚òÅÔ∏è WorkDrive" />}
        </Tabs>

        <TabPanel value={activeTab} index={0}>
          <FileUploadZone onFileSelect={onUpload} accept="audio/*" />
        </TabPanel>

        <TabPanel value={activeTab} index={1}>
          {/* ‚úÖ UTILISATION avec les nouvelles props */}
          <SimpleWorkdriveExplorer
            mode="audio_only" // ‚úÖ Mode sp√©cifique
            showSelectionSummary={true}
            onFilesSelect={handleWorkdriveSelection}
            maxSelections={{ audio: 1, transcription: 0 }}
          />
        </TabPanel>
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>Annuler</Button>
      </DialogActions>
    </Dialog>
  );
};
```

## üéØ **EXEMPLES D'UTILISATION**

### **1. Mode Audio Only (dans modal)**

```typescript
<SimpleWorkdriveExplorer
  mode="audio_only"
  showSelectionSummary={true}
  onFilesSelect={(audioFile) => {
    if (audioFile) handleAudioUpload(audioFile);
  }}
/>
```

### **2. Mode Transcription Only**

```typescript
<SimpleWorkdriveExplorer
  mode="transcription_only"
  showSelectionSummary={true}
  onFilesSelect={(_, transcriptionText) => {
    if (transcriptionText) handleTranscriptionUpload(transcriptionText);
  }}
/>
```

### **3. Mode Complet (existant)**

```typescript
<SimpleWorkdriveExplorer
  mode="full" // ou omis (par d√©faut)
  onFilesSelect={handleWorkdriveFilesSelect}
/>
```

## üéØ **Cas d'Usage D√©taill√©s**

### **Sc√©nario A : Transcription seule ‚Üí Ajout audio**

1. **√âtat initial** : `upload=false, transcription‚â†null`
2. **Interface** : Bouton [üéµ Ajouter Audio] visible
3. **Action utilisateur** : Clique sur bouton
4. **Modal** : S'ouvre avec onglets Disk/WorkDrive
5. **S√©lection** : Utilisateur choisit audio (disk ou WorkDrive)
6. **Upload** : Fichier upload√© dans bucket "Calls"
7. **Mise √† jour** : `upload=true, filepath=path, audiourl=signedUrl`
8. **R√©sultat** : Bouton [üîß Pr√©parer] devient disponible

### **Sc√©nario B : Audio seul ‚Üí Ajout transcription**

1. **√âtat initial** : `upload=true, transcription=null`
2. **Interface** : Bouton [üìù Ajouter Transcription] visible
3. **Action utilisateur** : Clique sur bouton
4. **Modal** : Modal upload transcription (JSON/TXT)
5. **Validation** : JSON valid√© avec `validateTranscriptionJSON`
6. **Mise √† jour** : `transcription=parsedJSON`
7. **R√©sultat** : Bouton [üîß Pr√©parer] devient disponible

### **Sc√©nario C : Pr√©paration technique**

1. **Pr√©requis** : `transcription ‚â† null`
2. **Action** : Clique sur [üîß Pr√©parer pour Tagging]
3. **Traitement** :
   - Cr√©ation ligne dans `transcript`
   - Parsing JSONB ‚Üí insertion dans `word`
   - `preparedfortranscript = true`
4. **R√©sultat** : Appel disponible dans onglet "Liste"

## üîç **Avantages de cette Nouvelle Architecture**

### **1. S√©paration des Responsabilit√©s**

- **Compl√©ment** : Actions m√©tier (ajouter fichiers)
- **Pr√©paration** : Actions techniques (transformation donn√©es)

### **2. UX Intuitive**

- Actions contextuelles selon l'√©tat de l'appel
- Progression visuelle claire : Compl√©ment ‚Üí Pr√©paration ‚Üí Tagging

### **3. Flexibilit√© des Sources**

- Upload depuis disque dur local
- Import depuis Zoho WorkDrive
- Extensible vers d'autres sources

### **4. √âvolutivit√©**

- Facile d'ajouter nouvelles sources (FTP, S3, etc.)
- Structure modulaire pour nouveaux types de fichiers
- Composants r√©utilisables

### **5. Coh√©rence**

- M√™me interface WorkDrive dans import et compl√©ment
- Logique de validation identique
- Gestion d'erreurs unifi√©e

## üß™ **Tests √† Impl√©menter**

### **Tests Unitaires**

1. **ComplementActionButtons** : Affichage conditionnel des boutons
2. **AudioUploadModal** : Fonctionnement des onglets
3. **SimpleWorkdriveExplorer** : Filtrage audioOnly
4. **CallPreparation** : √âtats et transitions

### **Tests d'Int√©gration**

1. **Workflow complet** : Import ‚Üí Compl√©ment ‚Üí Pr√©paration ‚Üí Tagging
2. **Gestion d'erreurs** : Upload failures, validation errors
3. **Performance** : Upload gros fichiers audio

### **Tests E2E**

1. **Sc√©nario utilisateur** : Compl√®tement un appel incomplet
2. **Multi-sources** : Alternance disk/WorkDrive
3. **√âtats persistants** : Refresh page, navigation

## üö® **Points d'Attention pour l'Impl√©mentation**

### **1. Gestion des √âtats de Chargement**

```typescript
const [uploadingAudio, setUploadingAudio] = useState<string | null>(null);
const [preparingCall, setPreparingCall] = useState<string | null>(null);

// Disable buttons pendant traitement
<Button
  disabled={uploadingAudio === call.callid}
  loading={uploadingAudio === call.callid}
>
  {uploadingAudio === call.callid ? "Upload..." : "Ajouter Audio"}
</Button>;
```

### **2. Validation Robuste**

```typescript
// Validation audio
const isValidAudioFile = (file: File) => {
  const validTypes = ["audio/mp3", "audio/wav", "audio/m4a"];
  const maxSize = 100 * 1024 * 1024; // 100MB

  return validTypes.includes(file.type) && file.size <= maxSize;
};

// Validation transcription
const isValidTranscription = (text: string) => {
  const result = validateTranscriptionJSON(text);
  return result.isValid;
};
```

### **3. Gestion des Erreurs Sp√©cifiques**

```typescript
// Erreurs r√©seau
try {
  await uploadAudio(file);
} catch (error) {
  if (error.code === "NETWORK_ERROR") {
    showMessage("Erreur r√©seau - V√©rifiez votre connexion");
  } else if (error.code === "FILE_TOO_LARGE") {
    showMessage("Fichier trop volumineux (max 100MB)");
  } else {
    showMessage(`Erreur d'upload: ${error.message}`);
  }
}
```

### **4. Performance et UX**

```typescript
// Progress bars pour uploads
const [uploadProgress, setUploadProgress] = useState<{
  [callId: string]: number;
}>({});

// D√©bounce pour √©viter clics multiples
const debouncedPrepareCall = useCallback(
  debounce(async (callId: string) => {
    await prepareCallForTagging(callId);
  }, 1000),
  []
);
```

---

## üìã **Notes de Session pour Claude**

**Session Date** : Discussions avec utilisateur sur am√©lioration UX onglet Pr√©paration

**Probl√®me identifi√©** : Bouton "Pr√©parer" m√©langeait compl√©ment de fichiers et pr√©paration technique

**Solution valid√©e** : S√©paration en deux colonnes distinctes avec modal multi-sources (disk/WorkDrive)

**Status** : Sp√©cifications approuv√©es, impl√©mentation √† faire

**Priorit√©** : Haute - Am√©lioration UX significative

**Composants impact√©s** :

- `CallPreparation.tsx` (refactoring majeur)
- `AudioUploadModal.tsx` (extension)
- `SimpleWorkdriveExplorer.tsx` (nouveaux props)
- Nouveaux composants : `ComplementActionButtons.tsx`

**Tests requis** : Workflow complet, sources multiples, √©tats persistants
