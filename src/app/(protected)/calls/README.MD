# ğŸ“ SpÃ©cifications du Workflow des Appels - Page /calls

## ğŸ¯ Vue d'ensemble

La page `/calls` gÃ¨re l'importation, la prÃ©paration et l'analyse des appels conversationnels via 3 onglets sÃ©quentiels.

## ğŸ“Š Structure de donnÃ©es

### Table `call` (champs clÃ©s)

```sql
call {
  callid          -- ID unique de l'appel
  transcription   -- JSONB contenant la transcription brute
  filepath        -- Chemin vers l'audio dans bucket "Calls"
  upload          -- BOOLÃ‰EN: Audio uploadÃ© dans le bucket
  preparedfortranscript -- BOOLÃ‰EN: PrÃªt pour le tagging (table word peuplÃ©e)
  audiourl        -- URL signÃ©e temporaire pour l'audio
  filename        -- Nom du fichier audio original
  description     -- Description de l'appel
  is_tagging_call -- BOOLÃ‰EN: Marque comme appel de tagging
}
```

### Ã‰tats possibles d'un appel

#### Relation `preparedfortranscript` â†” Tables `transcript`/`word`

**`preparedfortranscript = false`** â†’ **PAS de donnÃ©es dans `transcript`/`word`**

- Seul le JSONB `call.transcription` existe
- Tables `transcript` et `word` vides pour cet appel

**`preparedfortranscript = true`** â†’ **DonnÃ©es prÃ©sentes dans `transcript`/`word`**

- JSONB `call.transcription` transformÃ© en tours de parole
- Table `transcript` : 1 ligne avec `transcriptid`
- Table `word` : N lignes avec les mots/tours de parole

#### Ã‰tats dÃ©taillÃ©s

1. **Transcription importÃ©e** :
   - `transcription` â‰  null, `upload` = false, `preparedfortranscript` = false
   - âŒ Aucune donnÃ©e dans `transcript`/`word`
2. **Audio seul** :
   - `upload` = true, `transcription` = null, `preparedfortranscript` = false
   - âŒ Aucune donnÃ©e dans `transcript`/`word`
3. **Complet non prÃ©parÃ©** :
   - `transcription` â‰  null, `upload` = true, `preparedfortranscript` = false
   - âŒ Aucune donnÃ©e dans `transcript`/`word`
4. **PrÃ©parÃ© pour tagging** :
   - `preparedfortranscript` = true (avec ou sans audio)
   - âœ… DonnÃ©es dans `transcript`/`word` (transformation JSONB effectuÃ©e)

## ğŸ”„ Workflow en 3 phases

### ğŸ“¥ Phase 1 : Import (Onglet 1)

**Objectif** : Importer les fichiers depuis Zoho WorkDrive dans Supabase

**Sources** :

- Audio seul (MP3, WAV, etc.)
- Transcription seule (JSON)
- Audio + Transcription

**Actions** :

- `SimpleWorkdriveExplorer` â†’ SÃ©lection fichiers
- `handleCallSubmission()` â†’ Sauvegarde en base
- Stockage audio dans bucket "Calls" (si prÃ©sent)
- Stockage transcription en JSONB (si prÃ©sente)
- **âš ï¸ PROBLÃˆME ACTUEL** : Le code crÃ©e aussi `transcript`/`word` (Ã  corriger)
- **âœ… COMPORTEMENT SOUHAITÃ‰** : AUCUNE crÃ©ation dans tables `transcript`/`word`

**RÃ©sultat** :

```sql
INSERT INTO call {
  transcription: JSONB_ou_NULL,
  upload: true_si_audio_false_sinon,
  preparedfortranscript: false,
  is_tagging_call: true
}
```

### ğŸ”§ Phase 2 : PrÃ©paration (Onglet 2)

**Objectif** : SÃ©lectionner les appels Ã  analyser et transformer JSONB â†’ table `word`

**CritÃ¨res d'affichage** :

```sql
WHERE is_tagging_call = true
AND preparedfortranscript = false
```

**Interface** :

- Liste des appels avec bouton "VOIR JSONB" (lecture transcription)
- Bouton "PRÃ‰PARER POUR LE TAGGING"
- **NOUVEAU** : Association audio optionnelle si manquante

**Actions de prÃ©paration** :

1. **Si audio manquant** : Proposer upload optionnel (pas obligatoire)
2. **Si transcription prÃ©sente** : Parser JSONB â†’ Peupler tables `transcript` + `word`
3. **Marquer comme prÃ©parÃ©** : `preparedfortranscript = true`

**RÃ©sultat** :

- Tables `transcript` et `word` peuplÃ©es
- Appel disponible pour tagging

### ğŸ·ï¸ Phase 3 : Tagging (Onglet 3)

**Objectif** : Analyser et tagger les appels prÃ©parÃ©s

**CritÃ¨res d'affichage** :

```sql
WHERE is_tagging_call = true
AND preparedfortranscript = true
```

**Interface** :

- Table avec actions : Lire, Ã‰diter origine, Supprimer
- Lecteur audio (si disponible)
- Interface de tagging via `TranscriptLPL`

## âš ï¸ **PROBLÃˆMES ACTUELS IDENTIFIÃ‰S**

### 1. IncohÃ©rence dans `handleCallSubmission`

**Code actuel** âŒ :

```typescript
// Import WorkDrive fait DÃ‰JÃ€ transcript + word
if (parsedTranscription) {
  await insertTranscriptionWords(transcriptId, parsedTranscription, supabase);
}
// Mais marque preparedfortranscript = false
```

**Code souhaitÃ©** âœ… :

```typescript
// Import WorkDrive ne fait QUE stocker le JSONB
// Pas de crÃ©ation transcript/word
preparedfortranscript: false;
```

### 2. Filtrage incorrect dans l'onglet PrÃ©paration

**Code actuel** âŒ :

```sql
-- Dans CallListUnprepared
SELECT * FROM call WHERE preparedfortranscript = false
-- Manque le filtre is_tagging_call = true
```

**Code souhaitÃ©** âœ… :

```sql
SELECT * FROM call
WHERE is_tagging_call = true
-- Puis filtrage UI selon le besoin
```

### 3. Gestion audio obligatoire en prÃ©paration

**Comportement actuel** âŒ :

- `AudioUploadModal` demande obligatoirement un fichier
- Bloque la prÃ©paration si pas d'audio

**Comportement souhaitÃ©** âœ… :

- Audio optionnel avec bouton "Continuer sans audio"
- PossibilitÃ© de tagger sans audio

### 1. **Logique de filtrage des onglets**

#### Onglet 2 - PrÃ©paration (ACTUEL âŒ)

```sql
-- ProblÃ¨me : Se base sur 'upload' au lieu de 'preparedfortranscript'
WHERE upload = false OR preparedfortranscript = false
```

#### Onglet 2 - PrÃ©paration (CORRIGÃ‰ âœ…)

```sql
WHERE is_tagging_call = true
AND preparedfortranscript = false
```

#### Onglet 3 - Liste des appels (CORRIGÃ‰ âœ…)

```sql
WHERE is_tagging_call = true
AND preparedfortranscript = true
```

## ğŸ”§ **SPÃ‰CIFICATIONS TECHNIQUES DÃ‰TAILLÃ‰ES**

### **Import WorkDrive avec gestion des doublons**

#### Logique de dÃ©tection des doublons :

```typescript
// VÃ©rification avant import
const existingCall = await supabase
  .from("call")
  .select("*")
  .eq("filename", audioFile.name)
  .eq("is_tagging_call", true)
  .single();

if (existingCall) {
  // Analyser ce qui peut Ãªtre amÃ©liorÃ©
  const canUpgrade = {
    addAudio: !existingCall.upload && audioFile,
    addTranscription: !existingCall.transcription && transcriptionText,
  };

  if (canUpgrade.addAudio || canUpgrade.addTranscription) {
    // Proposer mise Ã  jour
  } else {
    // Bloquer ou crÃ©er doublon
  }
}
```

#### Dialog de mise Ã  jour proposÃ© :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ”„ Appel existant dÃ©tectÃ©               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Un appel avec ce nom existe dÃ©jÃ  :      â”‚
â”‚ "sonear_YvesRocher_0200.json"          â”‚
â”‚                                         â”‚
â”‚ Ã‰tat actuel : ğŸ“ Transcription seule    â”‚
â”‚ Nouvel import : ğŸµğŸ“ Audio + Transcript.â”‚
â”‚                                         â”‚
â”‚ [Ajouter l'audio manquant]             â”‚
â”‚ [CrÃ©er un nouvel appel]                 â”‚
â”‚ [Annuler]                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **Validation JSON stricte**

#### Structure JSON requise :

```typescript
interface ValidTranscriptionJSON {
  words: Array<{
    text: string; // Obligatoire
    startTime: number; // Obligatoire
    endTime: number; // Obligatoire
    speaker?: string; // Optionnel
    turn?: string; // Optionnel (alias de speaker)
    type?: string; // Optionnel
  }>;
}

// Fonction de validation
const validateTranscriptionJSON = (
  jsonString: string
): {
  isValid: boolean;
  error?: string;
  data?: ValidTranscriptionJSON;
} => {
  try {
    const parsed = JSON.parse(jsonString);

    if (!parsed.words || !Array.isArray(parsed.words)) {
      return {
        isValid: false,
        error: "PropriÃ©tÃ© 'words' manquante ou invalide",
      };
    }

    if (parsed.words.length === 0) {
      return { isValid: false, error: "Le tableau 'words' est vide" };
    }

    for (let i = 0; i < parsed.words.length; i++) {
      const word = parsed.words[i];

      if (!word.text || typeof word.text !== "string") {
        return {
          isValid: false,
          error: `Mot ${i}: propriÃ©tÃ© 'text' manquante`,
        };
      }

      if (
        typeof word.startTime !== "number" ||
        typeof word.endTime !== "number"
      ) {
        return { isValid: false, error: `Mot ${i}: timestamps invalides` };
      }

      if (word.startTime >= word.endTime) {
        return { isValid: false, error: `Mot ${i}: startTime >= endTime` };
      }
    }

    return { isValid: true, data: parsed };
  } catch (error) {
    return { isValid: false, error: "JSON invalide" };
  }
};
```

### **Actions de suppression Menu dÃ©roulant**

#### Composant BulkActionsToolbar Ã©tendu :

```typescript
// Dans CallTableList - Actions de suppression
const [deleteMenuAnchor, setDeleteMenuAnchor] = useState<null | HTMLElement>(
  null
);
const [selectedAction, setSelectedAction] = useState<
  "audio" | "analysis" | "complete" | null
>(null);

const handleDeleteMenuClick = (event: React.MouseEvent<HTMLElement>) => {
  setDeleteMenuAnchor(event.currentTarget);
};

const handleDeleteAction = async (
  action: "audio" | "analysis" | "complete"
) => {
  switch (action) {
    case "audio":
      // Supprimer fichier bucket + mettre upload = false
      await removeAudioOnly(selectedCallIds);
      break;
    case "analysis":
      // Supprimer transcript + word + preparedfortranscript = false
      await removeAnalysisData(selectedCallIds);
      break;
    case "complete":
      // Supprimer appel complet
      await removeCallsCompletely(selectedCallIds);
      break;
  }
};
```

### **Filtres avancÃ©s onglet PrÃ©paration**

#### Interface de filtrage :

```typescript
interface PreparationFilters {
  state: "all" | "to_prepare" | "prepared";
  content: "all" | "complete" | "audio_only" | "transcript_only" | "empty";
  status: "all" | "non_supervisÃ©" | "conflictuel" | "non_conflictuel";
  dateRange?: { start: Date; end: Date };
  hasWords: "all" | "yes" | "no"; // Pour dÃ©tecter les problÃ¨mes de synchro
}

// Logique de filtrage
const filterCalls = (calls: Call[], filters: PreparationFilters) => {
  return calls.filter((call) => {
    // Filtre par Ã©tat
    if (filters.state === "to_prepare" && call.preparedfortranscript)
      return false;
    if (filters.state === "prepared" && !call.preparedfortranscript)
      return false;

    // Filtre par contenu
    const hasAudio = call.upload && call.filepath;
    const hasTranscription = call.transcription?.words?.length > 0;

    switch (filters.content) {
      case "complete":
        return hasAudio && hasTranscription;
      case "audio_only":
        return hasAudio && !hasTranscription;
      case "transcript_only":
        return !hasAudio && hasTranscription;
      case "empty":
        return !hasAudio && !hasTranscription;
      default:
        return true;
    }
  });
};
```

### 3. **Actions de suppression**

#### Bouton poubelle actuel âŒ

- Fonction : `removeCallUpload()`
- Action : Supprime audio du bucket + vide table `word`
- Garde l'appel avec `upload = false`

#### Options de suppression proposÃ©es âœ…

**Option A : Suppression partielle**

- "Supprimer audio" â†’ Supprime fichier bucket, garde transcription/words
- "Supprimer complÃ¨tement" â†’ Supprime appel + audio + transcript + words

**Option B : Suppression intelligente**

- Si `upload = true` â†’ "Supprimer audio seulement" vs "Supprimer tout"
- Si `upload = false` â†’ "Supprimer appel" (tout supprimer)

**Option C : Menu contextuel**

```
ğŸ—‘ï¸ â–¼ Supprimer
â”œâ”€â”€ ğŸµ Audio seulement
â”œâ”€â”€ ğŸ“ DonnÃ©es d'analyse (words)
â””â”€â”€ âŒ Appel complet
```

### 4. **Indicateurs visuels**

#### Ã‰tat des appels dans les listes

- ğŸµ **Audio** : IcÃ´ne prÃ©sence audio
- ğŸ“ **Transcription** : IcÃ´ne prÃ©sence transcription
- âœ… **PrÃ©parÃ©** : Badge statut prÃ©paration
- ğŸ·ï¸ **TaggÃ©** : Nombre de tags appliquÃ©s

#### Messages d'Ã©tat

- "Audio + Transcription"
- "Transcription seule"
- "Audio seul"
- "PrÃªt pour tagging"

## ğŸ¨ Interface utilisateur dÃ©taillÃ©e

### Onglet 1 - Import WorkDrive

- **Titre** : "ğŸ“¥ Import depuis Zoho WorkDrive"
- **Sous-titre** : "Importez vos fichiers audio et transcriptions"
- **Interface** : `SimpleWorkdriveExplorer` (inchangÃ©)

### Onglet 2 - PrÃ©paration (VUE UNIFIÃ‰E)

- **Titre** : "ğŸ”§ PrÃ©paration et gestion des appels"
- **Sous-titre** : "GÃ©rez tous vos appels importÃ©s et prÃ©parez-les pour l'analyse"

#### Filtres d'affichage :

```
[Ã‰tat: Tous â–¼] [Contenu: Tous â–¼] [Statut: Tous â–¼] [ğŸ” Recherche dans transcription]
```

**Filtre Ã‰tat** :

- Tous les appels
- Ã€ prÃ©parer (`preparedfortranscript = false`)
- DÃ©jÃ  prÃ©parÃ©s (`preparedfortranscript = true`)

**Filtre Contenu** :

- Tous
- Audio + Transcription (`upload = true AND transcription â‰  null`)
- Audio seul (`upload = true AND transcription = null`)
- Transcription seule (`upload = false AND transcription â‰  null`)

**Filtre Statut** :

- Tous
- Non supervisÃ©
- Conflictuel
- Non conflictuel

#### Indicateurs visuels par appel :

```
â”Œâ”€ Ã‰tat â”€â”¬â”€ Statut â”€â”¬â”€ Fichier â”€â”¬â”€ Description â”€â”¬â”€ Actions â”€â”
â”‚ğŸµğŸ“ Audio+â”‚ âš« Non  â”‚ file.mp3 â”‚ Description  â”‚ [Voir]   â”‚
â”‚Transcript.â”‚supervisÃ©â”‚          â”‚              â”‚ [PrÃ©p.]  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ğŸ“ Transcriptâ”‚ ğŸ”´ Conf.â”‚ file.jsonâ”‚ Import Work..â”‚ [Voir]   â”‚
â”‚seule      â”‚         â”‚          â”‚              â”‚ [PrÃ©p.]  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚âœ… PrÃªt pourâ”‚ ğŸŸ¢ Non  â”‚ file.mp3 â”‚ Appel prÃ©parÃ©â”‚ [Liste]  â”‚
â”‚tagging    â”‚Conf.    â”‚          â”‚              â”‚          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**LÃ©gende des Ã©tats** :

- ğŸµğŸ“ = Audio + Transcription (prÃªt Ã  prÃ©parer)
- ğŸ“ = Transcription seule (prÃªt Ã  prÃ©parer)
- ğŸµ = Audio seul (nÃ©cessite transcription)
- âœ… = DÃ©jÃ  prÃ©parÃ© (lecture seule)
- âŒ = Vide (aucun contenu)

**Actions disponibles** :

- **[Voir JSONB]** : Affiche la transcription (si prÃ©sente)
- **[PrÃ©parer]** : Lance la prÃ©paration (si possible)
- **[â†’ Liste]** : Redirige vers l'onglet 3 (si dÃ©jÃ  prÃ©parÃ©)

### Onglet 3 - Tagging

- **Titre** : "ğŸ·ï¸ Appels prÃªts pour le tagging"
- **Sous-titre** : "Analysez et taguez vos appels prÃ©parÃ©s"
- **Interface** : `CallTableList` actuelle (inchangÃ©e)
- **Filtrage** : `WHERE is_tagging_call = true AND preparedfortranscript = true`

## âš¡ Actions techniques

### 1. Corriger les requÃªtes de filtrage

### 2. Modifier `prepareCallForTagging()` pour audio optionnel

### 3. RÃ©viser les actions de suppression

### 4. AmÃ©liorer les indicateurs visuels

### 5. Ajouter des messages d'Ã©tat clairs

## âœ… **RÃ‰PONSES VALIDÃ‰ES**

### 1. **Workflow de l'import** ğŸ”„

**âœ… VALIDÃ‰** : L'import WorkDrive ne crÃ©e PAS les tables `transcript`/`word`

- Import stocke seulement JSONB dans `call.transcription`
- PrÃ©paration crÃ©e `transcript`/`word` Ã  partir du JSONB
- `preparedfortranscript = false` Ã  l'import

### 2. **Gestion des doublons** ğŸ”

**âœ… VALIDÃ‰** : AmÃ©lioration intelligente des imports existants

- VÃ©rifier si appel existe dÃ©jÃ  (par filename/description)
- Si nouvel import apporte plus de contenu â†’ Proposer mise Ã  jour
- Exemple : Audio existant + nouvelle transcription â†’ "Voulez-vous ajouter la transcription ?"

### 3. **Actions de suppression dans l'onglet 3** ğŸ—‘ï¸

**âœ… VALIDÃ‰** : Option A - Suppression progressive

```
ğŸ—‘ï¸ â–¼ Supprimer
â”œâ”€â”€ ğŸµ Retirer l'audio (garde transcription + words)
â”œâ”€â”€ ğŸ“ Retirer les donnÃ©es d'analyse (words)
â””â”€â”€ âŒ Supprimer l'appel complet
```

### 4. **Ã‰tats des appels existants** ğŸ“Š

**âœ… VALIDÃ‰** : Tous les Ã©tats visibles dans l'onglet 2 avec filtres

- Onglet 2 affiche TOUS les appels de tagging (`is_tagging_call = true`)
- Filtres par Ã©tat : Tous/Ã€ prÃ©parer/DÃ©jÃ  prÃ©parÃ©s
- Pas de filtrage par dÃ©faut = vue complÃ¨te

### 5. **Audio optionnel dans TranscriptLPL** ğŸµ

**âœ… VALIDÃ‰** : TranscriptLPL fonctionne sans audio

- `TranscriptAudioPlayer` affiche "Aucun audio disponible" si `audioSrc` vide
- Tagging possible avec transcription seule

### 6. **Performance avec gros volumes** âš¡

**âœ… VALIDÃ‰** : 100 appels actuellement, milliers futurs

- Pas de pagination immÃ©diate nÃ©cessaire
- PrÃ©voir pagination pour Ã©volution future
- Filtres avancÃ©s suffisants pour l'instant

### 7. **Validation import JSON** âœ…

**âœ… VALIDÃ‰** : Validation structure JSON obligatoire

- VÃ©rifier prÃ©sence de `words` array
- Valider structure de chaque word : `{text, startTime, endTime, speaker/turn}`
- Rejeter les JSON invalides avec message explicite

### 8. **Workflow utilisateur prioritaire** ğŸ¯

**âœ… VALIDÃ‰** : Mix des cas A et B

- **Cas A** : Import transcription seule â†’ PrÃ©paration â†’ Tagging sans audio
- **Cas B** : Import audio + transcription â†’ PrÃ©paration â†’ Tagging avec audio
- Interface doit Ãªtre optimisÃ©e pour les deux workflows

## ğŸ“‹ **PLAN D'IMPLÃ‰MENTATION PRIORITAIRE**

### ğŸš¨ **Phase 1 - Corrections critiques** (ImmÃ©diat)

#### 1.1 Corriger l'import WorkDrive

```typescript
// Dans handleCallSubmission - SUPPRESSION de la crÃ©ation transcript/word
export const handleCallSubmission = async ({
  audioFile,
  description,
  transcriptionText,
  showMessage,
  onCallUploaded,
}) => {
  // ... upload audio si prÃ©sent

  // Validation JSON si transcription
  let parsedTranscription = null;
  if (transcriptionText) {
    const validation = validateTranscriptionJSON(transcriptionText);
    if (!validation.isValid) {
      throw new Error(`Transcription invalide: ${validation.error}`);
    }
    parsedTranscription = validation.data;
  }

  // Gestion des doublons
  const existingCall = await checkForDuplicates(audioFile?.name, description);
  if (existingCall) {
    return handleDuplicateDialog(existingCall, audioFile, parsedTranscription);
  }

  // Insert call SANS crÃ©er transcript/word
  const { data: callData } = await supabase.from("call").insert([
    {
      audiourl: audioUrl,
      filename: audioFile?.name,
      filepath: filePath,
      description,
      transcription: parsedTranscription, // JSONB seulement
      upload: !!audioFile,
      is_tagging_call: true,
      preparedfortranscript: false, // âœ… Pas prÃ©parÃ©
    },
  ]);

  // âŒ SUPPRIMÃ‰ : Pas de crÃ©ation transcript/word ici
};
```

#### 1.2 Corriger le filtrage onglet PrÃ©paration

```typescript
// Dans CallListUnprepared - AJOUT du filtre manquant
const fetchTaggingCalls = async () => {
  const { data, error } = await supabase
    .from("call")
    .select("*")
    .eq("is_tagging_call", true); // âœ… AJOUT de ce filtre
  // Pas de filtre sur preparedfortranscript = afficher TOUS
};
```

### ğŸ”§ **Phase 2 - AmÃ©liorations UX** (PrioritÃ© haute)

#### 2.1 Audio optionnel en prÃ©paration

```typescript
// Modifier AudioUploadModal pour accepter skip
<AudioUploadModal
  open={isAudioModalOpen}
  onClose={() => setIsAudioModalOpen(false)}
  onUpload={handleAudioUpload}
  allowSkip={true}
  skipLabel="Continuer sans audio"
  title="Association audio (optionnel)"
/>
```

#### 2.2 Vue unifiÃ©e avec filtres onglet PrÃ©paration

- Filtres Ã‰tat/Contenu/Statut comme spÃ©cifiÃ©
- Indicateurs visuels par type d'appel
- Actions contextuelles

### ğŸ¨ **Phase 3 - Suppressions avancÃ©es** (PrioritÃ© moyenne)

#### 3.1 Menu suppression onglet 3

```typescript
// Dans CallTableList - Remplacer bouton simple par menu
<IconButton onClick={handleDeleteMenuClick}>
  <DeleteIcon />
</IconButton>
<Menu anchorEl={deleteMenuAnchor} open={Boolean(deleteMenuAnchor)}>
  <MenuItem onClick={() => handleDeleteAction('audio')}>
    ğŸµ Retirer l'audio
  </MenuItem>
  <MenuItem onClick={() => handleDeleteAction('analysis')}>
    ğŸ“ Retirer les donnÃ©es d'analyse
  </MenuItem>
  <MenuItem onClick={() => handleDeleteAction('complete')}>
    âŒ Supprimer l'appel complet
  </MenuItem>
</Menu>
```

### ğŸš€ **Phase 4 - Optimisations futures** (PrioritÃ© basse)

#### 4.1 Pagination prÃ©paratoire

- ImplÃ©mentation pagination pour Ã©volution vers milliers d'appels
- Filtres par date de crÃ©ation/modification
- Recherche textuelle dans descriptions

#### 4.2 Monitoring et logs

- Suivi des actions de suppression
- Logs des imports/prÃ©parations
- MÃ©triques d'utilisation

## ğŸ› ï¸ **FICHIERS Ã€ MODIFIER**

### Phase 1 - Fichiers critiques :

- `callApiUtils.ts` : Corriger handleCallSubmission
- `CallListUnprepared.tsx` : Corriger filtrage
- Nouveaux fichiers : `validateTranscriptionJSON.ts`, `duplicateManager.ts`

### Phase 2 - Fichiers UX :

- `AudioUploadModal.tsx` : Ajouter option skip
- `CallListUnprepared.tsx` : Vue unifiÃ©e avec filtres
- `CallPreparation.tsx` : Adapter aux nouveaux workflows

### Phase 3 - Fichiers suppression :

- `CallTableList.tsx` : Menu suppression avancÃ©
- `removeCallUpload.ts` : Fonctions suppression granulaire
- Nouveaux : `bulkDeleteActions.ts`

## ğŸ§ª **TESTS PRIORITAIRES**

1. **Import WorkDrive** : VÃ©rifier qu'aucun transcript/word n'est crÃ©Ã©
2. **Gestion doublons** : Tester dÃ©tection et propositions d'amÃ©lioration
3. **PrÃ©paration** : Tester workflow avec/sans audio
4. **Filtrage** : VÃ©rifier que tous les appels apparaissent dans onglet 2
5. **Suppression** : Tester les 3 types de suppression
6. **Validation JSON** : Tester rejet des JSON invalides
