# Sp√©cifications - Am√©liorations du syst√®me de tagging TaggerLPL

## üéØ Objectif g√©n√©ral

Am√©liorer la compl√©tude et la coh√©rence des donn√©es d'analyse en automatisant le calcul du champ `next_turn_tag` lors du processus de tagging, permettant ainsi une analyse exhaustive des transitions conseiller-client dans les diagrammes de Sankey.

---

## üìã Modification 1 : Calcul automatique de `next_turn_tag` lors du tagging

### **Probl√®me identifi√©**

Actuellement, le champ `next_turn_tag` dans la table `turntagged` reste `NULL` lors de la cr√©ation d'un nouveau tag via l'interface de tagging. Il n'est rempli que lors d'op√©rations de gestion des tags (renommage/fusion) dans l'interface "Rationaliser les Tags".

**Cons√©quence :** Les diagrammes de Sankey n'affichent que les donn√©es correspondant aux tags qui ont √©t√© modifi√©s via l'interface de gestion, cr√©ant une analyse incompl√®te.

### **Solution propos√©e**

Ajouter une logique de calcul automatique du `next_turn_tag` dans la fonction `addTag()` du `TaggingDataProvider` pour identifier et r√©f√©rencer le tag du tour de parole imm√©diatement suivant.

### **Sp√©cifications techniques**

#### **1. Localisation du code**

- **Fichier :** `context/TaggingDataContext.tsx`
- **Fonction :** `addTag(newTag: NewTag)`
- **Ligne approximative :** ~380-420

#### **2. Logique √† impl√©menter**

```typescript
// Apr√®s insertion du nouveau tag, calculer next_turn_tag
const calculateNextTurnTag = async (
  insertedTag: TaggedTurn
): Promise<string | null> => {
  try {
    // 1. Identifier le tour de parole suivant (diff√©rent speaker)
    const nextWord = taggingTranscription.find(
      (word) =>
        word.turn !== insertedTag.speaker &&
        word.startTime > insertedTag.end_time
    );

    if (!nextWord) return null;

    const nextTurn = nextWord.turn;
    const nextTurnStartTime = nextWord.startTime;

    // 2. Chercher un tag existant pour ce tour suivant
    const { data: existingNextTag, error } = await supabase
      .from("turntagged")
      .select("tag")
      .eq("call_id", insertedTag.call_id)
      .eq("speaker", nextTurn)
      .gte("start_time", nextTurnStartTime)
      .lte("start_time", nextTurnStartTime + TOLERANCE_WINDOW) // 2-3 secondes
      .order("start_time", { ascending: true })
      .limit(1)
      .single();

    if (error && error.code !== "PGRST116") {
      console.error("Erreur lors de la recherche du tag suivant:", error);
      return null;
    }

    return existingNextTag?.tag || null;
  } catch (err) {
    console.error("Erreur dans calculateNextTurnTag:", err);
    return null;
  }
};

// 3. Mettre √† jour le tag ins√©r√© avec next_turn_tag
const nextTurnTag = await calculateNextTurnTag(enrichedTag);
if (nextTurnTag) {
  const { error: updateError } = await supabase
    .from("turntagged")
    .update({ next_turn_tag: nextTurnTag })
    .eq("id", enrichedTag.id);

  if (updateError) {
    console.error("Erreur mise √† jour next_turn_tag:", updateError);
  } else {
    enrichedTag.next_turn_tag = nextTurnTag;
  }
}
```

#### **3. Constantes √† d√©finir**

```typescript
// √Ä ajouter en haut du fichier
const TOLERANCE_WINDOW = 3.0; // Fen√™tre de tol√©rance en secondes pour trouver le tag suivant
```

#### **4. Interface TypeScript √† mettre √† jour**

```typescript
// Dans TaggedTurn interface (si pas d√©j√† pr√©sent)
export interface TaggedTurn {
  id: number;
  call_id: string;
  start_time: number;
  end_time: number;
  tag: string;
  next_turn_verbatim: string;
  next_turn_tag?: string; // ‚úÖ Rendre ce champ optionnel mais g√©r√©
  color: string;
  speaker: string;
  [key: string]: any;
}
```

### **Tests de validation**

#### **Cas de test 1 : Tag suivant existant**

- **Donn√©es :** Tour conseiller (10s-15s) suivi d'un tour client tagg√© (16s-20s)
- **Attendu :** `next_turn_tag` du tour conseiller = tag du tour client
- **Test :** Cr√©er tag conseiller ‚Üí v√©rifier que `next_turn_tag` est rempli

#### **Cas de test 2 : Pas de tag suivant**

- **Donn√©es :** Tour conseiller (10s-15s) suivi d'un tour client non tagg√©
- **Attendu :** `next_turn_tag` reste `NULL`
- **Test :** Cr√©er tag conseiller ‚Üí v√©rifier que `next_turn_tag` est `NULL`

#### **Cas de test 3 : Ordre de tagging invers√©**

- **Donn√©es :** Tag client cr√©√© avant tag conseiller pr√©c√©dent
- **Attendu :** `next_turn_tag` du conseiller mis √† jour automatiquement
- **Test :** Tag client ‚Üí Tag conseiller ‚Üí v√©rifier liaison

### **Impact sur l'existant**

#### **Donn√©es existantes**

- **Conservation :** Les tags existants avec `next_turn_tag = NULL` ne seront pas modifi√©s
- **Compatibilit√© :** Le code reste compatible avec les donn√©es actuelles
- **Migration optionnelle :** Possibilit√© d'ajouter une fonction de recalcul pour l'historique

#### **Performance**

- **Impact minimal :** Une requ√™te suppl√©mentaire par tag cr√©√©
- **Optimisation :** Utilisation d'index sur `(call_id, speaker, start_time)`
- **Timeout :** Gestion des erreurs avec fallback gracieux

### **Livrable**

#### **Code modifi√©**

- [ ] Fonction `addTag()` dans `TaggingDataContext.tsx`
- [ ] Fonction utilitaire `calculateNextTurnTag()`
- [ ] Gestion d'erreurs et logging appropri√©
- [ ] Tests unitaires pour les cas d√©crits

#### **Documentation**

- [ ] Mise √† jour de la documentation technique
- [ ] Commentaires dans le code pour expliquer la logique
- [ ] Guide de test pour validation

#### **Validation**

- [ ] Tests en environnement de d√©veloppement
- [ ] V√©rification des diagrammes de Sankey avec nouvelles donn√©es
- [ ] Test de non-r√©gression sur l'interface existante

---

## üìã Modification 2 : Correction du filtre par origine dans les diagrammes de Sankey

### **Probl√®me identifi√©**

Le filtre par origine dans `TagAnalysisGraphs` ne fonctionne pas correctement. Bien que l'interface affiche un dropdown avec les origines disponibles et que le state `selectedOrigin` soit mis √† jour, le filtrage des donn√©es ne s'applique pas effectivement aux diagrammes de Sankey.

**Analyse du code actuel :**

- Le dropdown r√©cup√®re bien les origines depuis `call.origine`
- Le `useEffect` se d√©clenche lors du changement de `selectedOrigin`
- Mais la logique de filtrage dans `fetchData()` pr√©sente des dysfonctionnements

### **Solution propos√©e**

Corriger la logique de filtrage dans la fonction `fetchData()` pour s'assurer que les donn√©es affich√©es correspondent bien √† l'origine s√©lectionn√©e.

### **Sp√©cifications techniques**

#### **1. Localisation du code**

- **Fichier :** `components/TagAnalysisGraphs.tsx`
- **Fonction :** `fetchData()`
- **Lignes approximatives :** ~80-150

#### **2. Probl√®me dans le code actuel**

```typescript
// Code actuel probl√©matique - lignes ~90-105
let callIds: string[] | null = null;
if (selectedOrigin) {
  const { data: callsData, error: callsError } = await supabase
    .from("call")
    .select("callid")
    .eq("origine", selectedOrigin);

  if (callsError) throw new Error(callsError.message);
  callIds = callsData.map((call) => call.callid);
}

// Plus loin - lignes ~110-115
const query = supabase.from("turntagged").select(`...`);
if (callIds) {
  query.in("call_id", callIds);
}
```

#### **3. Correction √† apporter**

```typescript
// Code corrig√©
const fetchData = async () => {
  setLoading(true);
  try {
    // 1. R√©cup√©rer les tags et familles (inchang√©)
    const { data: tagsData, error: tagsError } = await supabase
      .from("lpltag")
      .select("label, family")
      .in("family", allowedFamilies);

    if (tagsError) throw new Error(tagsError.message);

    const tagToFamily = Object.fromEntries(
      tagsData.map(({ label, family }) => [label, family])
    );

    // 2. Construire la requ√™te avec filtrage par origine
    let query = supabase.from("turntagged").select(`
      id,
      call_id,
      tag,
      next_turn_tag,
      verbatim,
      next_turn_verbatim, 
      next_turn_tag_auto, 
      score_auto
    `);

    // 3. Filtrage par origine si s√©lectionn√©e
    if (selectedOrigin) {
      // Sous-requ√™te pour obtenir les call_ids de l'origine s√©lectionn√©e
      const { data: filteredCalls, error: callsError } = await supabase
        .from("call")
        .select("callid")
        .eq("origine", selectedOrigin);

      if (callsError) {
        console.error("Erreur lors du filtrage par origine:", callsError);
        throw new Error(callsError.message);
      }

      if (!filteredCalls || filteredCalls.length === 0) {
        console.warn(`Aucun appel trouv√© pour l'origine: ${selectedOrigin}`);
        setData({ nodes: [], links: [] });
        setRefletData({ nodes: [], links: [] });
        setLoading(false);
        return;
      }

      const callIds = filteredCalls.map((call) => call.callid);
      console.log(
        `Filtrage par origine "${selectedOrigin}": ${callIds.length} appels trouv√©s`
      );

      query = query.in("call_id", callIds);
    }

    // 4. Ex√©cuter la requ√™te
    const { data: turnTaggedData, error: turnTaggedError } = await query;

    if (turnTaggedError) throw new Error(turnTaggedError.message);

    console.log(
      `Donn√©es r√©cup√©r√©es: ${turnTaggedData?.length || 0} enregistrements`
    );

    // 5. Traitement des donn√©es (reste inchang√©)
    // ... reste du code existant pour aggregatedData, sankeyNodes, etc.
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : "Erreur inconnue";
    setError(errorMessage);
    console.error("Erreur lors du fetch :", errorMessage);
  } finally {
    setLoading(false);
  }
};
```

#### **4. Am√©liorations suppl√©mentaires**

**A. Indicateur visuel du filtrage actif**

```typescript
// √Ä ajouter dans le composant
{
  selectedOrigin && (
    <Typography
      variant="body2"
      sx={{
        mb: 2,
        padding: 1,
        backgroundColor: theme.palette.info.light,
        borderRadius: 1,
      }}
    >
      üìä Donn√©es filtr√©es par origine: <strong>{selectedOrigin}</strong>
      {/* Optionnel: afficher le nombre d'appels */}
    </Typography>
  );
}
```

**B. Gestion du cas "aucune donn√©e"**

```typescript
// Apr√®s le traitement des donn√©es
if (sankeyLinks.length === 0) {
  console.warn(
    `Aucune transition trouv√©e${
      selectedOrigin ? ` pour l'origine "${selectedOrigin}"` : ""
    }`
  );
}
```

#### **5. Logging et debugging**

```typescript
// Ajouter des logs pour faciliter le debugging
console.log("=== FILTRAGE SANKEY ===");
console.log("Origine s√©lectionn√©e:", selectedOrigin);
console.log("Nombre d'appels filtr√©s:", callIds?.length || "tous");
console.log("Enregistrements turntagged r√©cup√©r√©s:", turnTaggedData?.length);
console.log("Transitions g√©n√©r√©es:", sankeyLinks.length);
```

### **Tests de validation**

#### **Cas de test 1 : Filtrage par origine sp√©cifique**

- **Action :** S√©lectionner une origine dans le dropdown
- **Attendu :** Diagramme mis √† jour avec uniquement les donn√©es de cette origine
- **V√©rification :** Comparer les donn√©es avant/apr√®s filtrage

#### **Cas de test 2 : Retour √† "Tout afficher"**

- **Action :** S√©lectionner "Tout afficher" apr√®s un filtrage
- **Attendu :** Diagramme montre toutes les donn√©es
- **V√©rification :** Nombre total de transitions restaur√©

#### **Cas de test 3 : Origine sans donn√©es**

- **Action :** S√©lectionner une origine sans appels tagg√©s
- **Attendu :** Diagramme vide avec message appropri√©
- **V√©rification :** Pas d'erreur, interface gracieuse

#### **Cas de test 4 : Performance**

- **Action :** Changer rapidement d'origine plusieurs fois
- **Attendu :** Pas de doublon de requ√™tes, loading states corrects
- **V√©rification :** Network tab + logs console

### **Impact sur l'existant**

#### **Compatibilit√©**

- **Fonctionnalit√© existante :** Le comportement "Tout afficher" reste identique
- **Interface :** Aucun changement visuel requis
- **Performance :** Am√©lioration possible gr√¢ce au filtrage en amont

#### **Base de donn√©es**

- **Index recommand√© :** `CREATE INDEX IF NOT EXISTS idx_call_origine ON call(origine);`
- **Index existant :** V√©rifier `turntagged(call_id)` pour les jointures

### **Livrable**

#### **Code modifi√©**

- [ ] Fonction `fetchData()` dans `TagAnalysisGraphs.tsx`
- [ ] Am√©lioration du logging et gestion d'erreurs
- [ ] Indicateurs visuels du filtrage actif

#### **Tests**

- [ ] Tests unitaires pour chaque cas de filtrage
- [ ] Tests d'int√©gration avec donn√©es r√©elles
- [ ] Validation des performances

#### **Documentation**

- [ ] Commentaires dans le code expliquant la logique de filtrage
- [ ] Mise √† jour de la documentation utilisateur

---

## üîÑ Modifications connexes √† pr√©voir

### **Modification 1.1 : Mise √† jour r√©troactive (optionnelle)**

**Objectif :** Recalculer les `next_turn_tag` pour les donn√©es existantes

**Approche :** Fonction utilitaire ex√©cutable √† la demande

```typescript
const backfillNextTurnTags = async (callId?: string) => {
  // Logique de recalcul pour l'historique
};
```

### **Modification 1.2 : Interface d'administration**

**Objectif :** Ajouter un bouton dans l'interface pour d√©clencher le recalcul

**Localisation :** Page d'analyse ou interface "Rationaliser les Tags"

### **Modification 2.1 : Optimisation des filtres multiples**

**Objectif :** Permettre le filtrage simultan√© par origine ET par p√©riode/date

**Approche :** Extension du syst√®me de filtrage actuel

### **Modification 3 : Refonte de l'onglet "Statistiques des tags" avec nouveaux graphiques**

**Objectif :** Remplacer le graphique en barres actuel par des visualisations plus pertinentes pour l'analyse des strat√©gies

**Inspirations :** Graphiques bas√©s sur la recherche IEEE ProComm25 sur les descriptions d'actions dans les conversations conflictuelles

#### **3.1 Graphique principal : Tableau de r√©partition par strat√©gie et sentiment**

**Description :** Tableau montrant la r√©partition des r√©actions (Negative/Neutral/Positive) pour chaque strat√©gie

**Sp√©cifications visuelles :**

- **Format :** Tableau avec colonnes color√©es par sentiment
- **Colonnes :** Strategy | Negative (%) | Neutral (%) | Positive (%)
- **Lignes :** Une ligne par famille de tags (Explanation, Engagement, Opening, Reflection)
- **Couleurs :**
  - Negative : Rouge (#FF4444)
  - Neutral : Orange/Jaune (#FFA500)
  - Positive : Vert (#4CAF50)

**Structure des donn√©es :**

```typescript
interface StrategyStats {
  strategy: string; // "Explanation", "Engagement", "Opening", "Reflection"
  negative: number; // Pourcentage
  neutral: number; // Pourcentage
  positive: number; // Pourcentage
  total: number; // Nombre total d'occurrences
}
```

**Calcul des donn√©es :**

```sql
-- Requ√™te pour g√©n√©rer les statistiques
SELECT
  lpltag.family as strategy,
  COUNT(*) as total,
  COUNT(CASE WHEN turntagged.next_turn_tag = 'CLIENT NEGATIF' THEN 1 END) * 100.0 / COUNT(*) as negative,
  COUNT(CASE WHEN turntagged.next_turn_tag = 'CLIENT NEUTRE' THEN 1 END) * 100.0 / COUNT(*) as neutral,
  COUNT(CASE WHEN turntagged.next_turn_tag = 'CLIENT POSITIF' THEN 1 END) * 100.0 / COUNT(*) as positive
FROM turntagged
JOIN lpltag ON turntagged.tag = lpltag.label
WHERE turntagged.next_turn_tag IS NOT NULL
  AND lpltag.family IN ('EXPLANATION', 'ENGAGEMENT', 'OUVERTURE', 'REFLET')
GROUP BY lpltag.family;
```

#### **3.2 Graphique secondaire : Barres horizontales des r√©actions positives**

**Description :** Graphique en barres horizontales montrant uniquement les pourcentages de r√©actions positives par strat√©gie

**Sp√©cifications visuelles :**

- **Format :** Barres horizontales ordonn√©es par pourcentage d√©croissant
- **Axe Y :** Noms des strat√©gies (Opening, Engagement, Reflection, Explanation)
- **Axe X :** Pourcentage de r√©actions positives (0-100%)
- **Couleurs :** D√©grad√© de vert selon l'efficacit√©
- **Annotations :** Pourcentage affich√© sur chaque barre

**Key Finding automatique :**

```typescript
// Calcul automatique du insight principal
const generateKeyFinding = (stats: StrategyStats[]) => {
  const sortedByPositive = stats.sort((a, b) => b.positive - a.positive);
  const best = sortedByPositive[0];
  const worst = sortedByPositive[sortedByPositive.length - 1];
  const difference = Math.round(best.positive - worst.positive);

  return `Action-centered strategies (${
    best.strategy
  } + Opening) generate ${difference}% more positive reactions than ${worst.strategy.toLowerCase()}`;
};
```

### **Sp√©cifications techniques**

#### **1. Localisation du code**

- **Fichier principal :** `components/TagStats.tsx`
- **Remplacement complet :** Remplacer le graphique ECharts actuel
- **Nouveaux composants :**
  - `StrategyStatsTable.tsx`
  - `PositiveReactionsChart.tsx`

#### **2. Nouvelles interfaces TypeScript**

```typescript
interface StrategyStats {
  strategy: string;
  negative: number;
  neutral: number;
  positive: number;
  total: number;
}

interface StrategyStatsProps {
  family?: string | null; // Maintenir la compatibilit√© avec le filtre existant
}

interface TableCellProps {
  value: number;
  type: "negative" | "neutral" | "positive";
  total?: number;
}
```

#### **3. Structure du nouveau composant TagStats**

```typescript
const TagStats: FC<StrategyStatsProps> = ({ family }) => {
  const [strategyStats, setStrategyStats] = useState<StrategyStats[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [keyFinding, setKeyFinding] = useState<string>("");

  // Fonction de fetch des donn√©es
  const fetchStrategyStats = async () => {
    // Logique de r√©cup√©ration et calcul des pourcentages
  };

  // Calcul automatique du key finding
  const generateInsight = (stats: StrategyStats[]) => {
    // Logique de g√©n√©ration d'insights
  };

  return (
    <Box sx={{ padding: 2 }}>
      <Typography variant="h5" gutterBottom>
        {family
          ? `Statistiques pour ${family}`
          : "Impact des Strat√©gies sur les R√©actions Client"}
      </Typography>

      {/* Tableau principal */}
      <StrategyStatsTable data={strategyStats} />

      {/* Graphique des r√©actions positives */}
      <PositiveReactionsChart data={strategyStats} />

      {/* Key Finding automatique */}
      <Box sx={{ mt: 3, p: 2, backgroundColor: "info.light", borderRadius: 1 }}>
        <Typography variant="body1" sx={{ fontWeight: "bold" }}>
          Key Finding: {keyFinding}
        </Typography>
      </Box>
    </Box>
  );
};
```

#### **4. Composant StrategyStatsTable**

```typescript
const StrategyStatsTable: FC<{ data: StrategyStats[] }> = ({ data }) => {
  return (
    <TableContainer component={Paper} sx={{ mb: 3 }}>
      <Table>
        <TableHead>
          <TableRow sx={{ backgroundColor: "#f5f5f5" }}>
            <TableCell>
              <strong>Strategy</strong>
            </TableCell>
            <TableCell align="center" sx={{ color: "#FF4444" }}>
              <strong>Negative (%)</strong>
            </TableCell>
            <TableCell align="center" sx={{ color: "#FFA500" }}>
              <strong>Neutral (%)</strong>
            </TableCell>
            <TableCell align="center" sx={{ color: "#4CAF50" }}>
              <strong>Positive (%)</strong>
            </TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {data.map((row) => (
            <TableRow key={row.strategy}>
              <TableCell>
                <strong>{row.strategy}</strong>
              </TableCell>
              <TableCell
                align="center"
                sx={{ color: "#FF4444", fontSize: "1.1rem" }}
              >
                {row.negative.toFixed(1)}
              </TableCell>
              <TableCell
                align="center"
                sx={{ color: "#FFA500", fontSize: "1.1rem" }}
              >
                {row.neutral.toFixed(1)}
              </TableCell>
              <TableCell
                align="center"
                sx={{ color: "#4CAF50", fontSize: "1.1rem" }}
              >
                {row.positive.toFixed(1)}
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );
};
```

#### **5. Composant PositiveReactionsChart**

```typescript
const PositiveReactionsChart: FC<{ data: StrategyStats[] }> = ({ data }) => {
  const sortedData = [...data].sort((a, b) => b.positive - a.positive);

  return (
    <Box sx={{ mb: 3 }}>
      <Typography variant="h6" gutterBottom>
        Positive Reactions by Strategy
      </Typography>
      {sortedData.map((item, index) => (
        <Box key={item.strategy} sx={{ mb: 1 }}>
          <Box
            sx={{ display: "flex", justifyContent: "space-between", mb: 0.5 }}
          >
            <Typography variant="body2">{item.strategy}</Typography>
            <Typography variant="body2" sx={{ fontWeight: "bold" }}>
              {item.positive.toFixed(1)}%
            </Typography>
          </Box>
          <LinearProgress
            variant="determinate"
            value={item.positive}
            sx={{
              height: 24,
              borderRadius: 1,
              backgroundColor: "#f0f0f0",
              "& .MuiLinearProgress-bar": {
                backgroundColor: index === 0 ? "#4CAF50" : "#81C784",
                borderRadius: 1,
              },
            }}
          />
        </Box>
      ))}
    </Box>
  );
};
```

### **Tests de validation**

#### **Cas de test 1 : Donn√©es compl√®tes**

- **Donn√©es :** Appels avec next_turn_tag rempli pour toutes les familles
- **Attendu :** Tableau et graphique avec pourcentages corrects
- **V√©rification :** Somme des pourcentages = 100% par ligne

#### **Cas de test 2 : Filtrage par famille**

- **Action :** S√©lectionner une famille sp√©cifique
- **Attendu :** Affichage des statistiques pour cette famille uniquement
- **V√©rification :** Coh√©rence avec les donn√©es filtr√©es

#### **Cas de test 3 : Donn√©es manquantes**

- **Donn√©es :** Certaines familles sans next_turn_tag
- **Attendu :** Gestion gracieuse, affichage partiel
- **V√©rification :** Messages appropri√©s pour donn√©es insuffisantes

### **Migration et compatibilit√©**

#### **Remplacement progressif**

1. **Phase 1 :** Cr√©er les nouveaux composants en parall√®le
2. **Phase 2 :** Ajouter un toggle pour basculer entre ancien/nouveau
3. **Phase 3 :** Remplacer d√©finitivement et supprimer l'ancien code

#### **D√©pendances**

- **Nouvelles :** `@mui/material/Table`, `@mui/material/LinearProgress`
- **Supprim√©es :** `echarts` (si utilis√© uniquement pour TagStats)
- **Conservation :** Interface et props compatibles avec l'usage actuel

### **Livrable**

#### **Code nouveau**

- [ ] `StrategyStatsTable.tsx` - Tableau de r√©partition
- [ ] `PositiveReactionsChart.tsx` - Graphique barres horizontales
- [ ] `TagStats.tsx` refactoris√© - Orchestration des composants
- [ ] Fonctions de calcul des statistiques et insights

#### **Tests et validation**

- [ ] Tests unitaires pour calculs de pourcentages
- [ ] Tests d'int√©gration avec donn√©es r√©elles
- [ ] Validation visuelle des graphiques

#### **Documentation**

- [ ] Documentation des nouveaux composants
- [ ] Guide de migration pour les utilisateurs
- [ ] Explication des m√©triques et calculs

---

_Cette sp√©cification sera compl√©t√©e avec d'autres am√©liorations du syst√®me dans les prochaines versions._
