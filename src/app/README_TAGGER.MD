# Documentation TaggerLPL - Application Next.js

## Vue d'ensemble

TaggerLPL est une application Next.js d√©di√©e au tagging et √† l'analyse d'appels. L'application utilise une architecture moderne avec React Server Components et Client Components.

## Structure des fichiers principaux

### 1. Page d'accueil (`page.tsx`)

```typescript
import { redirect } from "next/navigation";

export default function Home() {
  redirect("/tagging");

  // Ce code ne sera jamais ex√©cut√© en raison de la redirection
  return null;
}
```

**Analyse :**

- **R√¥le** : Point d'entr√©e de l'application (route `/`)
- **Comportement** : Redirection automatique vers `/tagging`
- **Type** : Server Component (par d√©faut)
- **Pourquoi cette approche ?** : L'application n'a pas besoin d'une vraie page d'accueil, elle redirige directement vers la fonctionnalit√© principale de tagging

### 2. Layout racine (`layout.tsx`)

```typescript
"use client";

import { ReactNode } from "react";
// ... imports des providers et composants

interface RootLayoutProps {
  children: ReactNode;
}

export default function RootLayout({ children }: RootLayoutProps) {
  // Structure HTML avec providers imbriqu√©s
}
```

**Analyse :**

- **R√¥le** : Template global pour toutes les pages
- **Type** : Client Component (directive `"use client"`)
- **Architecture** : Utilise le pattern Provider pour la gestion d'√©tat globale

#### Hi√©rarchie des Providers :

1. `AppRouterCacheProvider` (Material-UI)
2. `SupabaseProvider` (Base de donn√©es)
3. `ThemeModeProvider` (Gestion des th√®mes)
4. `ZohoProvider` (Int√©gration Zoho)
5. `TaggingDataProvider` (Donn√©es de tagging)

### 3. Styles globaux (`globals.css`)

```css
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

/* Th√®me sombre automatique */
@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}
```

**Analyse :**

- **Framework CSS** : Tailwind CSS
- **Th√®me** : Support automatique du mode sombre
- **Variables CSS** : Couleurs personnalis√©es pour background/foreground

### 4. M√©tadonn√©es (`metadata.ts`)

```typescript
export const metadata = {
  title: "TaggerLPL - Application de tagging",
  description: "Application de tagging pour l'analyse d'appels",
};
```

## Architecture technique

### Technologies utilis√©es

- **Framework** : Next.js 14+ (App Router)
- **UI** : Material-UI (MUI) + Tailwind CSS
- **Base de donn√©es** : Supabase
- **CRM** : Int√©gration Zoho
- **√âtat global** : React Context API
- **Langue** : Interface en fran√ßais

### Flux de navigation

```
/ (page d'accueil) ‚Üí redirect ‚Üí /tagging (fonctionnalit√© principale)
```

---

## Composants principaux

### 1. GlobalNavbar - Navigation intelligente

**Localisation** : `@/components/layout/GlobalNavbar`

**Fonctionnalit√©s cl√©s :**

- **Navigation adaptative** : Comportement diff√©rent selon le type de page (publique vs prot√©g√©e)
- **Auto-hide intelligent** : Se masque lors du d√©filement vers le bas, r√©appara√Æt au survol ou d√©filement vers le haut
- **Zone de d√©tection** : Zone invisible de 20px en haut pour r√©afficher la navbar au survol
- **Hauteur fixe** : 48px constant pour √©viter les d√©calages de layout

**Pages prot√©g√©es** (avec auto-hide) :

- `/dashboard`, `/calls`, `/tagging`, `/new-tagging`, `/tags/admin`, `/analysis`

**Pages publiques** (navbar statique) :

- Toutes les autres pages

**Composants int√©gr√©s :**

- `AuthStatus` : Gestion de l'authentification
- `ThemeToggle` : Basculement mode clair/sombre
- Liens de navigation contextuels

### 2. TaggingDataProvider - Gestion d'√©tat globale

**Localisation** : `@/context/TaggingDataContext`

**Mod√®les de donn√©es :**

```typescript
interface Tag {
  id?: number;
  label: string; // ‚úÖ Correspond √† votre DB lpltag.label
  color?: string;
  description?: string;
  family?: string;
  callCount?: number;
  turnCount?: number;
}

interface TaggingCall {
  callid: string;
  is_tagging_call: boolean;
  preparedfortranscript: boolean;
  audiourl: string;
  filename?: string;
  filepath?: string;
  upload?: boolean;
}

interface Word {
  id: number;
  transcriptid: string;
  word: string;
  text: string; // ‚úÖ Alias de word
  startTime: number;
  endTime: number;
  speaker: string;
  turn: string; // ‚úÖ Propri√©t√© pour le groupement
  index?: number; // ‚úÖ Index dans la transcription
}

interface TaggedTurn {
  id: number;
  call_id: string;
  start_time: number;
  end_time: number;
  tag: string;
  verbatim: string;
  next_turn_verbatim: string;
  next_turn_tag?: string; // ‚úÖ Tag du tour suivant
  speaker: string;
  color: string;
}

interface NewTag {
  call_id: string;
  start_time: number;
  end_time: number;
  tag: string;
  verbatim: string;
  next_turn_verbatim?: string;
  speaker: string;
  next_turn_tag?: string;
}
```

**Fonctionnalit√©s principales :**

- **Gestion des appels** : Liste, s√©lection, filtrage des appels de tagging
- **Transcription** : R√©cup√©ration et synchronisation des mots avec timestamps
- **Lecture audio** : Contr√¥le du lecteur audio avec saut √† timestamp
- **Tagging** : Ajout, suppression, gestion des tags sur les segments
- **Post-its** : Gestion des annotations textuelles

**Hooks expos√©s :**

- `fetchTaggingTranscription(callId)` : Charge la transcription d'un appel
- `selectTaggingCall(call)` : S√©lectionne un appel et charge ses donn√©es (‚úÖ **CORRIG√â** : charge maintenant automatiquement les tags)
- `playAudioAtTimestamp(timestamp)` : Lance la lecture √† un moment pr√©cis
- `addTag(newTag)` : Ajoute un nouveau tag
- `deleteTurnTag(id)` : Supprime un tag
- `fetchTaggedTurns(callId)` : ‚úÖ **NOUVEAU** : R√©cup√®re les tags d'un appel

**‚úÖ CORRECTION IMPORTANTE - selectTaggingCall :**

```typescript
const selectTaggingCall = useCallback(
  (call: TaggingCall): void => {
    setSelectedTaggingCall(call);

    if (call?.callid) {
      // ‚úÖ Charger TOUTES les donn√©es n√©cessaires en parall√®le
      Promise.all([
        fetchTaggingTranscription(call.callid),
        fetchTaggedTurns(call.callid), // ‚úÖ AJOUT CRUCIAL
        fetchTaggingPostits(call.callid),
      ]);

      setAudioSrc(call.audiourl);
    }
  },
  [fetchTaggingTranscription, fetchTaggedTurns, fetchTaggingPostits]
);
```

### 3. NewTaggingPage - Interface moderne de tagging

**Localisation** : `/new-tagging/page.tsx`

**Architecture :**

- **S√©lection d'appel** : Dropdown avec liste des appels disponibles
- **Gestion des URLs sign√©es** : G√©n√©ration d'URLs temporaires pour les fichiers audio
- **Chargement progressif** : √âtats de loading pour une meilleure UX
- **Fallback intelligent** : Gestion des appels avec/sans audio
- **Switch de version** : Possibilit√© de revenir √† l'ancienne interface

**Flux de traitement :**

1. Chargement de la liste des appels depuis `TaggingDataProvider`
2. S√©lection d'un appel via dropdown
3. V√©rification de la pr√©sence d'audio (`upload` et `filepath`)
4. G√©n√©ration d'URL sign√©e si n√©cessaire
5. ‚úÖ **Chargement automatique des tags existants**
6. Chargement de la transcription
7. Rendu du composant `TranscriptLPL`

**Gestion des diff√©rents cas :**

- **Appel avec audio** : URL sign√©e + transcription + tags
- **Appel sans audio** : Transcription + tags uniquement
- **Erreur de chargement** : Fallback gracieux

### 4. Contexts suppl√©mentaires

#### SupabaseProvider

- **R√¥le** : Gestion de la connexion et session Supabase
- **Fonctionnalit√©s** : Auth state, client Supabase global

#### ThemeModeProvider

- **R√¥le** : Gestion du th√®me clair/sombre
- **D√©faut** : Mode sombre
- **Composant** : `ThemeToggle` pour basculer

#### ZohoProvider

- **R√¥le** : Gestion des tokens d'API Zoho
- **Fonctionnalit√©s** : Refresh token, access token

---

## Structure des pages

### Page `/tagging` (ancienne version)

```
/tagging
‚îú‚îÄ‚îÄ layout.tsx (wrapper simple)
‚îú‚îÄ‚îÄ page.tsx (ProtectedRoute + ClientTaggerPage)
‚îî‚îÄ‚îÄ ClientTaggerPage.tsx (TaggerLPL dynamique)
```

### Page `/new-tagging` (nouvelle version)

- Interface √©pur√©e avec dropdown
- Meilleure gestion des √©tats de chargement
- ‚úÖ **Chargement automatique des tags au changement d'appel**
- Switch vers ancienne version possible

---

## Composants de transcription et tagging

### 1. TranscriptLPL - Composant principal de transcription

**Localisation** : `@/components/TranscriptLPL`

**Architecture modulaire :**

- **TranscriptHeader** : Affichage du nom de fichier
- **TranscriptAudioPlayer** : Lecteur audio int√©gr√©
- **TranscriptControls** : Contr√¥les de taille de police et toggle du panneau
- **TranscriptText** : ‚úÖ **CORRIG√â** : Affichage de la transcription avec tags existants
- **TagSidePanel** : Panneau lat√©ral pour gestion des tags

**Fonctionnalit√©s cl√©s :**

- **Synchronisation audio-texte** : Les mots se surlignent en temps r√©el
- **S√©lection de texte** : S√©lection de segments pour tagging
- **Navigation temporelle** : Clic sur mot = saut √† timestamp
- **Panneau lat√©ral r√©tractable** : 350px de largeur fixe
- **Responsivit√©** : Adaptation dynamique avec transition CSS
- ‚úÖ **Affichage des tags existants** : Les tags s'affichent automatiquement au chargement

#### Hooks personnalis√©s int√©gr√©s :

**useTaggingLogic** - Gestion des interactions de tagging

- Modes "create" et "edit" pour les tags
- S√©lection de texte avec calcul des timestamps
- CRUD complet sur les tags (ajout, modification, suppression)
- Gestion du verbatim et du "next turn"
- Logique de speakers/turns de parole
- ‚úÖ **Gestion robuste des index** : Validation des s√©lections de texte

**useTranscriptAudio** - Gestion audio et affichage

- Synchronisation temps r√©el audio/transcription
- Styles dynamiques des mots (surbrillance, couleurs des tags)
- ‚úÖ **Groupement par tours de parole corrig√©** : Logique de groupement optimis√©e
- Contr√¥les de taille de police (12-30px)

**‚úÖ CORRECTION IMPORTANTE - useTranscriptAudio.groupedTurns :**

```typescript
// ‚úÖ Calculer les groupes de tours de parole - VERSION CORRIG√âE
const groupedTurns = useMemo(() => {
  if (!taggingTranscription || taggingTranscription.length === 0) {
    return [];
  }

  const groups: TranscriptWord[][] = [];
  let currentGroup: TranscriptWord[] = [];
  let currentSpeaker: string | null = null;

  for (let i = 0; i < taggingTranscription.length; i++) {
    const word = taggingTranscription[i];
    const speaker = word.turn || word.speaker || "Inconnu";

    // Si nouveau speaker ou premier mot
    if (speaker !== currentSpeaker) {
      // Sauvegarder le groupe pr√©c√©dent s'il existe
      if (currentGroup.length > 0) {
        groups.push([...currentGroup]);
      }
      // Commencer un nouveau groupe
      currentGroup = [word];
      currentSpeaker = speaker;
    } else {
      // M√™me speaker, ajouter au groupe actuel
      currentGroup.push(word);
    }
  }

  // Ajouter le dernier groupe s'il existe
  if (currentGroup.length > 0) {
    groups.push(currentGroup);
  }

  return groups;
}, [taggingTranscription]);
```

### 2. TranscriptText - Affichage des tags existants

**‚úÖ PROBL√àME R√âSOLU** : Les tags existants ne s'affichaient pas au chargement

**Probl√®me identifi√©** : La logique de correspondance entre les tags et les tours de parole √©tait trop restrictive.

**Solution impl√©ment√©e** :

```typescript
// ‚úÖ Fonction pour trouver les tags qui intersectent avec un tour de parole - VERSION FINALE
const findTagsForTurn = (turn: any[]) => {
  if (!turn || turn.length === 0) return [];

  const turnStartTime = turn[0].startTime;
  const turnEndTime = turn[turn.length - 1].endTime;
  const turnSpeaker = turn[0].turn || turn[0].speaker;

  return taggedTurns.filter((tag) => {
    // V√©rifier qu'il y a une intersection temporelle
    const hasTimeOverlap =
      tag.start_time < turnEndTime && tag.end_time > turnStartTime;

    // ‚úÖ Logique de correspondance des speakers am√©lior√©e
    const speakerMatches =
      tag.speaker === turnSpeaker ||
      tag.speaker === turn[0].turn ||
      tag.speaker === turn[0].speaker ||
      // Mappings sp√©ciaux pour votre syst√®me
      (turnSpeaker === "conseiller_F11" &&
        (tag.speaker === "gare" || tag.speaker === "conseiller")) ||
      (turnSpeaker === "gare" && tag.speaker === "conseiller_F11") ||
      (turnSpeaker === "appelant" && tag.speaker.includes("spk")) ||
      (tag.speaker === "appelant" && turnSpeaker.includes("spk"));

    return speakerMatches && hasTimeOverlap;
  });
};
```

**Mappings de speakers g√©r√©s** :

- `conseiller_F11` ‚Üî `gare`
- `appelant` ‚Üî `spk*` (spk2 spk1, spk1 spk2, etc.)
- Correspondances directes par nom

### 3. TaggerLPL - Interface compl√®te de gestion

**Localisation** : `@/components/TaggerLPL`

**Vue d'ensemble :**
Interface principale avec drawer lat√©ral (35% de largeur) combinant :

- Chargement d'appels (`CallUploaderTaggerLPL`)
- Visualisation de transcription (`TranscriptLPL`)
- Gestion avanc√©e des tags

**Modes d'affichage :**

1. **Mode Tagging** : Transcription + tagging d'un appel
2. **Mode Gestion des Tags** : Administration compl√®te des tags

#### Fonctionnalit√©s de gestion des tags :

**Structure hi√©rarchique :**

```typescript
interface FamilyNode {
  family: string; // "agent", "client", "divers"
  icon: string; // Priorit√© d'affichage
  children: Tag[]; // Tags de cette famille
}

interface Tag {
  label: string; // Nom du tag
  color: string; // Couleur d'affichage
  callCount: number; // Nombre d'appels utilisant ce tag
  turnCount: number; // Nombre de segments tagg√©s
  family: string; // Famille d'appartenance
}
```

**Op√©rations avanc√©es :**

- **Fusion de tags** : Unification de tags similaires
- **Renommage** : Mise √† jour globale dans toute la DB
- **Historique** : Tra√ßabilit√© des modifications avec restauration
- **Statistiques** : Compteurs d'usage par tag/famille

**Syst√®me d'historique :**

- Table `tag_modifications` pour audit trail
- Sauvegarde des √©tats avant/apr√®s modification
- Fonction de restauration point-in-time

### 4. Syst√®me d'authentification

**ProtectedRoute** - Garde d'authentification

```typescript
// V√©rifie la session Supabase
// Redirige vers /login si non authentifi√©
// √âtat de chargement avec spinner
```

**AuthStatus** - Composant d'√©tat utilisateur

- Affichage avatar/email utilisateur
- Menu dropdown avec d√©connexion
- Int√©gration avec `SupabaseContext`
- Gestion des erreurs de session

### 5. Architecture des donn√©es

**Mod√®les principaux :**

```typescript
// Mot de transcription avec timing
interface TranscriptWord {
  text: string;
  startTime: number;
  endTime: number;
  turn: string; // Speaker/interlocuteur
}

// Segment tagg√©
interface TaggedTurn {
  id: string;
  call_id: string;
  start_time: number;
  end_time: number;
  tag: string;
  verbatim: string; // Texte s√©lectionn√©
  next_turn_verbatim: string; // ‚úÖ Contexte suivant (tour de parole qui suit)
  speaker: string;
  color: string;
}

// D√©finition de tag
interface LPLTag {
  label: string;
  description: string;
  family: string; // "agent", "client", "divers"
  color: string;
}
```

**Tables Supabase :**

- `call` : M√©tadonn√©es des appels
- `transcript` : Lien callid ‚Üí transcriptid
- `word` : Mots individuels avec timestamps
- `turntagged` : Segments tagg√©s
- `lpltag` : D√©finitions des tags
- `tag_modifications` : Historique des changements

---

## ‚úÖ FLUX DE TAGGING COMPLET (Mis √† jour)

### 1. üñ±Ô∏è S√©lection de texte √† la souris

**D√©clencheur** : `onMouseUp` sur `TranscriptText`

### 2. üîç Traitement dans `useTaggingLogic.handleMouseUp`

1. **R√©cup√©ration de la s√©lection**
   ```typescript
   const selection = window.getSelection();
   const selectedText = selection.toString().trim();
   ```
2. **Identification des mots s√©lectionn√©s**
   ```typescript
   const startWordIndex = parseInt(startContainer.dataset.index);
   const endWordIndex = parseInt(endContainer.dataset.index);
   ```
3. ‚úÖ **Validation robuste des index**
   ```typescript
   if (
     isNaN(startWordIndex) ||
     isNaN(endWordIndex) ||
     startWordIndex < 0 ||
     endWordIndex < 0 ||
     startWordIndex >= taggingTranscription.length ||
     endWordIndex >= taggingTranscription.length ||
     startWordIndex > endWordIndex
   ) {
     console.warn("Index invalides");
     return;
   }
   ```
4. **Calcul des timestamps**
   ```typescript
   const startTime = taggingTranscription[startWordIndex].startTime;
   const endTime = taggingTranscription[endWordIndex].endTime;
   ```

### 3. üéØ Ouverture du panneau de s√©lection

Le `TagSidePanel` s'ouvre avec :

- Mode "create"
- Texte s√©lectionn√© affich√©
- Timestamps calcul√©s
- Interface `TagSelector`

### 4. üè∑Ô∏è S√©lection d'un tag

Clic sur un tag ‚Üí `onSelectTag` ‚Üí `handleSaveTag`

### 5. üíæ Sauvegarde intelligente

1. **Identification du speaker**
2. ‚úÖ **Calcul du next_turn_verbatim** (contexte suivant)
3. **Construction de l'objet tag**
4. **V√©rification des doublons**
5. **Insertion ou mise √† jour en base**
6. ‚úÖ **Mise √† jour optimiste de l'√©tat local**

### 6. üé® Affichage automatique

‚úÖ Le tag appara√Æt imm√©diatement avec sa couleur gr√¢ce √† la correspondance corrig√©e dans `findTagsForTurn`.

---

## Optimisations techniques

**Performance :**

- Composants `memo()` pour √©viter re-renders
- Hooks `useCallback` pour stabilit√© des fonctions
- ‚úÖ **useMemo** pour groupedTurns √©vite recalculs inutiles
- Lazy loading avec `dynamic()` pour TaggerLPL

**UX/UI :**

- Transitions CSS fluides (0.3s ease)
- √âtats de loading explicites
- ‚úÖ **Gestion d'erreurs gracieuse** avec fallbacks
- Responsive design avec Material-UI

**Types TypeScript :**

- Interfaces compl√®tes pour tous les mod√®les
- Props typ√©es pour tous les composants
- Constantes partag√©es (DRAWER_WIDTH = 350px)

---

## Diff√©rences entre versions

### Ancienne version (/tagging)

- Interface tout-en-un avec drawer lat√©ral
- Chargement d'appels via accordion
- Gestion compl√®te des tags int√©gr√©e
- Mode administrateur pour fusion/renommage

### Nouvelle version (/new-tagging)

- Interface √©pur√©e avec dropdown
- Focus sur l'exp√©rience de tagging
- ‚úÖ **Chargement automatique des tags**
- Pas de gestion administrative
- Switch vers ancienne version possible

---

## TagSelector - Interface de s√©lection des tags

**Localisation** : `@/components/TagSelector`

**Architecture des familles :**

```typescript
interface GroupedTags {
  ENGAGEMENT: Tag[]; // Techniques d'engagement client
  REFLET: Tag[]; // Techniques de reflet/√©coute
  EXPLICATION: Tag[]; // Explications techniques/produits
  OUVERTURE: Tag[]; // Techniques d'ouverture commercial
  CLIENT: Tag[]; // R√©actions/√©tats du client
  OTHERS: Tag[]; // Divers/non cat√©goris√©s
}
```

**Layout responsive :**

- **Ligne 1** : ENGAGEMENT | REFLET (50/50)
- **Ligne 2** : EXPLICATION | OUVERTURE (50/50)
- **Ligne 3** : CLIENT (3 colonnes)
- **Ligne 4** : AUTRES (auto-fit, min 150px)

---

## Syst√®me de s√©curit√© des fichiers

**Fonction `generateSignedUrl` :**

```typescript
generateSignedUrl(filePath: string, expiration?: number): Promise<string>
```

**Fonctionnement :**

- **Bucket Supabase** : `"Calls"` pour stockage des fichiers audio
- **URLs temporaires** : Validit√© par d√©faut 20 minutes (1200s)
- **S√©curit√©** : Acc√®s contr√¥l√© sans exposition directe des fichiers

---

## ‚úÖ PROBL√àMES R√âSOLUS DANS CETTE SESSION

### 1. Tags existants ne s'affichaient pas au chargement

**Cause** : `fetchTaggedTurns` n'√©tait pas appel√© dans `selectTaggingCall`

**Solution** : Ajout de l'appel dans le contexte :

```typescript
const selectTaggingCall = useCallback(
  (call: TaggingCall): void => {
    setSelectedTaggingCall(call);
    if (call?.callid) {
      Promise.all([
        fetchTaggingTranscription(call.callid),
        fetchTaggedTurns(call.callid), // ‚úÖ AJOUT CRUCIAL
        fetchTaggingPostits(call.callid),
      ]);
      setAudioSrc(call.audiourl);
    }
  },
  [fetchTaggingTranscription, fetchTaggedTurns, fetchTaggingPostits]
);
```

### 2. Correspondance des speakers trop stricte

**Cause** : Les tags en base avaient des speakers diff√©rents de ceux de la transcription

**Solution** : Logique de mapping dans `findTagsForTurn` :

```typescript
const speakerMatches =
  tag.speaker === turnSpeaker ||
  // Mappings sp√©ciaux pour votre syst√®me
  (turnSpeaker === "conseiller_F11" && tag.speaker === "gare") ||
  (turnSpeaker === "appelant" && tag.speaker.includes("spk"));
```

### 3. Logique de groupement des tours de parole

**Cause** : Logique `forEach` avec condition complexe cr√©ait des groupes mal form√©s

**Solution** : Boucle `for` plus claire avec gestion explicite du dernier groupe

### 4. Gestion des index invalides

**Cause** : S√©lections de texte pouvaient g√©n√©rer des index hors limites

**Solution** : Validation robuste dans `handleMouseUp`

---

## Architecture finale - Vue d'ensemble

### Flux de donn√©es principal

```
SupabaseProvider (session auth)
‚îú‚îÄ‚îÄ ThemeModeProvider (UI themes)
‚îÇ   ‚îú‚îÄ‚îÄ ZohoProvider (CRM integration)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TaggingDataProvider (business logic)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ GlobalNavbar (navigation)
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ Pages
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ /tagging (TaggerLPL - interface compl√®te)
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ /new-tagging (NewTaggingPage - interface √©pur√©e)
‚îÇ   ‚îÇ               ‚îî‚îÄ‚îÄ TranscriptLPL (transcription + tagging)
‚îÇ   ‚îÇ                   ‚îú‚îÄ‚îÄ TranscriptText (affichage + tags existants ‚úÖ)
‚îÇ   ‚îÇ                   ‚îú‚îÄ‚îÄ TagSidePanel (gestion tags)
‚îÇ   ‚îÇ                   ‚îî‚îÄ‚îÄ TagSelector (s√©lection tags)
```

### Base de donn√©es Supabase

**Tables principales :**

- `call` ‚Üí `transcript` ‚Üí `word` (cha√Æne de transcription)
- `turntagged` ‚Üê `lpltag` (relation tags/segments)
- `tag_modifications` (audit trail)

**S√©curit√© :**

- Row Level Security (RLS) sur toutes les tables
- URLs sign√©es pour fichiers audio
- Authentification obligatoire via `ProtectedRoute`

---

## Recommandations techniques

### Points forts √† maintenir

1. **Hooks personnalis√©s** excellents pour r√©utilisabilit√©
2. **Syst√®me d'audit** tr√®s professionnel
3. **Architecture modulaire** facilite maintenance
4. **Types TypeScript** complets
5. ‚úÖ **Syst√®me de next_turn_verbatim** tr√®s intelligent pour l'analyse

### Am√©liorations sugg√©r√©es

1. **Tests unitaires** pour hooks complexes
2. **Error boundaries** explicites
3. **Documentation JSDoc** pour fonctions complexes
4. **Optimisation** continue des re-renders

---

## Notes pour Claude futur

Cette application est un **syst√®me de tagging conversationnel tr√®s sophistiqu√©** avec :

- ‚úÖ **Affichage temps r√©el** des tags existants
- ‚úÖ **Correspondance robuste** entre speakers
- ‚úÖ **Syst√®me de contexte** (next_turn_verbatim) pour analyse conversationnelle
- ‚úÖ **Interface intuitive** pour annotation rapide
- ‚úÖ **Architecture modulaire** bien organis√©e

**Points d'attention pour maintenance future :**

- La correspondance des speakers peut n√©cessiter des ajustements selon les donn√©es
- Le syst√®me `next_turn_verbatim` est crucial pour l'analyse m√©tier
- Les performances sont optimis√©es mais surveiller les re-renders sur gros volumes
